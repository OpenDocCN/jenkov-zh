# 面向服务的架构(SOA)

> 原文:[https://jenkov.com/tutorials/soa/soa.html](https://jenkov.com/tutorials/soa/soa.html)

面向服务的体系结构(SOA)是一种体系结构，其中独立的系统和应用程序通过公开和使用服务来相互通信。服务是使用开放标准定义的，这使得内部通信更容易实现，并且更少依赖于专有通信协议。

## 从 DOA 到 SOA

SOA 遵循分布式对象架构(DOA)的思想，其中应用程序中的对象可以在服务器之间自由移动，并远程调用彼此。其思想是，调用另一个对象的对象不必知道被调用的对象是驻留在本地还是远程。这对调用对象应该是透明的。

这种架构正慢慢被抛弃，因为太细粒度的分布式对象通信既非常复杂，又不能很好地执行。

分布式对象很复杂，因为调用远程对象比调用本地对象更容易出错。例如，您通常需要两阶段提交事务来协调分布式事务，而单阶段事务可以在本地完成。

此外，您无法控制不必要的进程外通信以及在“容器”或“服务器”之间背着您移动对象所产生的通信开销。因此，应用程序设计人员希望能够控制对象的位置，以降低复杂性并提高性能。

<center>

| ![A distributed object architecture.](../Images/79b0a8ad6c3a67999b7bf0c229132304.png) |
| **分布式对象架构。** |

</center>

取而代之的是引入了粒度更大、移动性更低的服务——SOA。服务可以移动，但是它们通常不会像人们想象的分布式对象那样动态移动。此外，当您调用服务时，您通常会意识到您正在调用一个远程实体。这意味着您可以更好地控制复杂性和性能。

<center>

| ![A service oriented architecture (SOA).](../Images/310340cca949dbfbb0f98120036a8a26.png) |
| 面向服务的架构。 |

</center>

一些人讽刺地说 SOA 代表“相同的旧架构”——这实际上与事实相差不远。今天的服务与昨天的远程过程调用协议惊人地相似。主要的区别是，今天的服务越来越多地通过开放标准进行通信，如 SOAP、REST 等。这意味着通信层变得更容易实现。然而，SOA 并不像一些作者想让你相信的那样，是“投资回报”的大增倍器。

另一个不同之处是 SOA 引入了一组新概念，并试图在整个行业中标准化一些现有的概念。这些概念包括:

*   企业服务总线
*   服务组合
*   服务交易
*   服务存储库
*   服务编排

我将在后面的文章中深入探讨这些概念。