# 阿姆达尔定律

> 原文:[https://jen kov . com/tutorials/Java-concurrency/am dahls-law . html](https://jenkov.com/tutorials/java-concurrency/amdahls-law.html)

阿姆达尔定律可以用来计算并行运行一部分计算可以加速多少。阿姆达尔定律是以 1967 年提出该定律的吉恩·阿姆达尔命名的。大多数使用并行或并发系统的开发人员对潜在的加速有一种直观的感觉，即使他们不知道阿姆达尔定律。不管怎样，阿姆达尔定律仍然是有用的。

我将首先从数学上解释阿姆达尔定律，然后用图表说明阿姆达尔定律。

## 阿姆达尔定律定义

可以并行化的程序(或算法)可以分成两部分:

*   不能并行化的零件
*   可以并行化的部分

想象一个从磁盘处理文件的程序。该程序的一小部分可以扫描该目录，并在内存内部创建一个文件列表。之后，每个文件被传递给一个单独的线程进行处理。扫描目录和创建文件列表的部分不能并行化，但是处理文件可以。

串行(非并行)执行程序所花费的总时间称为 T。时间 T 包括不可并行化部分和可并行化部分的时间。不可并行的部分称为 b。可并行的部分称为 T - B。下面的列表总结了这些定义:

*   T =串行执行的总时间
*   B =不可并行部分的总时间
*   T - B =可并行部分的总时间(串行执行，而非并行执行)

由此得出结论:

```
T = B + (T-B)

```

乍一看，程序的可并行化部分在等式中没有自己的符号，这可能有点奇怪。然而，由于方程的可并行化部分可以使用总时间 T 和 B(不可并行化部分)来表示，所以该方程实际上在概念上被简化了，这意味着它以这种形式包含更少的不同变量。

可并行化的部分`T - B`，可以通过并行执行来加速。它能加速多少取决于你应用多少线程或 CPU 来执行它。线程或 CPU 的数量称为 n。因此，可并行化部分的最快执行速度为:

```
(T - B) / N

```

另一种写法是:

```
(1/N) * (T - B)

```

维基百科使用这个版本，以防你在那里读到阿姆达尔定律。

根据阿姆达尔定律，当使用 N 个线程或 CPU 执行可并行化部分时，程序的总执行时间为:

```
T(N) = B + (T - B) / N

```

T(N)表示并行化因子为 N 的总执行时间。因此，T 可以写成 T(1)，表示并行化因子为 1 的总执行时间。用 T(1)代替 T，阿姆达尔定律看起来是这样的:

```
T(N) = B + ( T(1) - B ) / N

```

但意思还是一样。

### 计算实例

为了更好地理解阿姆达尔定律，我们来看一个计算例子。执行程序的总时间设置为 1。程序的不可并行部分占总时间 1 的 40%，等于 0.4。因此，可并行化部分等于`1 - 0.4 = 0.6`。

并行化因子为 2 (2 个线程或 CPU 执行可并行化部分，因此 N 为 2)的程序的执行时间为:

```
T(2) = 0.4 + ( 1 - 0.4 ) / 2
     = 0.4 + 0.6 / 2
     = 0.4 + 0.3
     = 0.7

```

使用并行因子 5 而不是 2 进行相同的计算，结果如下:

```
T(5) = 0.4 + ( 1 - 0.4 ) / 5
     = 0.4 + 0.6 / 5
     = 0.4 + 0.12
     = 0.52

```

## 阿姆达尔定律图解

为了更好地理解阿姆达尔定律，我将试着举例说明该定律是如何推导出来的。

首先，程序可以分为不可并行化的部分 B 和可并行化的部分 1-B，如下图所示:

![Amdahls law illustrated.](../Images/3a87901822cf4d737f79df5ca6f10db2.png)

顶部带分隔符的行是总时间 T(1)。

这里您可以看到并行化因子为 2 的执行时间:

![Amdahls law illustrated with a parallelization factor of 2.](../Images/c69c0d4f4bd2c470b8c51a69ae692665.png)

这里您可以看到并行化系数为 3 的执行时间:

![Amdahls law illustrated with a parallelization factor of 3.](../Images/e2d65400617be6e538733915d9b66149.png)

## 优化算法

根据阿姆达尔定律，很自然地，可并行化的部分可以通过硬件来更快地执行。更多线程/CPU。然而，不可并行化的部分只能通过优化代码来更快地执行。因此，您可以通过优化不可并行的部分来提高程序的速度和可并行性。您甚至可以通过将一些工作转移到可并行化的部分(如果可能的话)来改变算法，使其具有更小的不可并行化的部分。

### 优化顺序部分

如果你优化了程序的顺序部分，你也可以使用阿姆达尔定律来计算优化后程序的执行时间。如果不可并行化的部分 B 被优化了因子 O，那么阿姆达尔定律看起来是这样的:

```
T(O,N) = B / O + (1 - B / O) / N

```

记住，程序的不可并行部分现在需要`B / O`时间，所以可并行部分需要`1 - B / O`时间。

如果 B 为 0.4，O 为 2，N 为 5，则计算如下:

```
T(2,5) = 0.4 / 2 + (1 - 0.4 / 2) / 5
       = 0.2 + (1 - 0.4 / 2) / 5
       = 0.2 + (1 - 0.2) / 5
       = 0.2 + 0.8 / 5
       = 0.2 + 0.16
       = 0.36

```

## 执行时间与加速比

到目前为止，我们只使用阿姆达尔定律来计算程序或算法在优化或并行化后的执行时间。我们也可以使用阿姆达尔定律来计算*加速比*，意思是新算法或程序比旧版本快多少。

如果旧版本的程序或算法的时间是 T，那么加速将是

```
Speedup = T / T(O,N)

```

我们通常将 T 设置为 1，只是为了计算执行时间和加速比，作为旧时间的一部分。等式看起来是这样的:

```
Speedup = 1 / T(O,N)

```

如果我们插入阿姆达尔定律计算而不是 T(O，N)，我们得到下面的公式:

```
Speedup = 1 / ( B / O + (1 - B / O) / N )

```

当 B = 0.4，O = 2，N = 5 时，计算公式为:

```
Speedup = 1 / ( 0.4 / 2 + (1 - 0.4 / 2) / 5)
        = 1 / ( 0.2 + (1 - 0.4 / 2) / 5)
        = 1 / ( 0.2 + (1 - 0.2) / 5 )
        = 1 / ( 0.2 + 0.8 / 5 )
        = 1 / ( 0.2 + 0.16 )
        = 1 / 0.36
        = 2.77777 ...

```

这意味着，如果您将非并行化(顺序)部分优化 2 倍，将可并行化部分并行化 5 倍，程序或算法的新优化版本将比旧版本最多快 2.77777 倍。

## 衡量，不要只是计算

虽然阿姆达尔定律使您能够计算算法并行化的理论加速，但不要过于依赖这样的计算。在实践中，当您优化或并行化算法时，许多其他因素可能会发挥作用。

内存、CPU 缓存、磁盘、网卡等的速度。(如果使用磁盘或网络)也可能是一个限制因素。如果一个新版本的算法被并行化，但导致更多的 CPU 缓存未命中，您甚至可能无法获得使用 x N 个 CPU 所需的 x N 加速。如果你最终使内存总线、磁盘、网卡或网络连接饱和，情况也是如此。

我的建议是使用阿姆达尔定律来了解在哪里进行优化，但是使用测量来确定优化的实际加速。请记住，有时高度序列化的顺序(单 CPU)算法可能优于并行算法，这只是因为顺序版本没有协调开销(分解工作并重新构建总数)，并且因为单 CPU 算法可能更好地符合底层硬件的工作方式(CPU 管道、CPU 缓存等)。