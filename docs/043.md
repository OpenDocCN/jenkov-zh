# Java 列表

> 原文：<https://jenkov.com/tutorials/java-collections/list.html>

*Java List* 接口`java.util.List`，表示有序的对象序列。Java `List`中包含的元素可以根据它们在 Java `List`中出现的顺序被插入、访问、迭代和删除。元素的排序是这个数据结构被称为*列表*的原因。

Java 中的每个元素都有一个索引。`List`中的第一个元素的索引为 0，第二个元素的索引为 1，依此类推。索引的意思是“距离列表开头多少个元素”。因此，第一个元素距离列表的开头 0 个元素——因为它在列表的开头。

您可以将任何 Java 对象添加到`List`中。如果`List`没有类型化，使用 [Java 泛型](/java-generics/index.html)，那么你甚至可以在同一个`List`中混合不同类型(类)的对象。然而，在实践中，在同一个`List`中混合不同类型的对象并不常见。

Java `List`接口是标准的 [Java 接口](/java/interfaces.html)，是 [Java 集合](collection.html)接口的子类型，意思是`List`继承自`Collection`。

## Java 列表教程视频

如果你喜欢看视频而不是阅读文本，这里有一个 Java List 教程的视频版本:

<iframe width="560" height="315" src="https://www.youtube.com/embed/d3QbptJRln4" frameborder="0" allowfullscreen=""><h2>列表与集合</h2> <p>Java <code>List</code>和<a href="set.html"> Java Set </a>接口非常相似，因为它们都表示元素的集合。然而，有一些显著的差异。这些差异反映在<code>List</code>和<code>Set</code>接口提供的方法中。</p> <p>Java <code>List</code>和 Java <code>Set</code>接口的第一个区别是，同一个元素可以在 Java <code>List</code>中出现不止一次。这与 Java <code>Set</code>不同，在 Java 中每个元素只能出现一次。</p> <p>Java <code>List</code>和 Java <code>Set</code>接口的第二个区别是，<code>List</code>中的元素是有顺序的，元素可以按照这个顺序迭代。Java <code>Set</code>对内部保存的元素的顺序不做任何承诺。</p> <h2>列出实现</h2> <p>作为<code>Collection</code>子类型，<code>Collection</code>接口中的所有方法在<code>List</code>接口中也是可用的。</p> <p>因为<code>List</code>是一个接口，为了使用它，你需要实例化该接口的一个具体实现。您可以在 Java Collections API 的以下<code>List</code>实现中进行选择:</p> <ul> <li>java.util.ArrayList</li> <li>java.util.LinkedList</li> <li>java.util .向量</li> <li>java.util.Stack</li> </ul> <p>在这些实现中，ArrayList 是最常用的。</p> <p>在<code>java.util.concurrent</code>包中也有并发的<code>List</code>实现。这些<code>List</code>实现在我的<a href="/java-util-concurrent/index.html"> java.util.concurrent 教程</a>中有更详细的解释。</p> <h2>创建列表</h2> <p>通过创建一个实现 List 接口的类的实例，可以创建一个 List 实例。下面是一些如何创建<code>List</code>实例的例子:</p> <pre class="codeBox"> List listA = new ArrayList(); List listB = new LinkedList(); List listC = new Vector(); List listD = new Stack(); </pre> <p>请记住，大多数情况下您将使用 ArrayList 类，但是也有使用其他实现的情况。</p> <h2>通用列表</h2> <p>默认情况下，您可以将任何<code>Object</code>放入<code>List</code>中，但是从 Java 5 开始，Java 泛型使得限制您可以插入到<code>List</code>中的对象类型成为可能。这里有一个例子:</p> <pre class="codeBox"> List&lt;MyObject&gt; list = new ArrayList&lt;MyObject&gt;(); </pre> <p>这个<code>List</code>现在只能插入<code>MyObject</code>个实例。然后，您可以访问和迭代它的元素，而无需强制转换它们。这是它的样子:</p> <pre class="codeBox"> List&lt;MyObject&gt; list = new ArrayList&lt;MyObject&gt;(); list.add(new MyObject("First MyObject")); MyObject myObject = list.get(0); for(MyObject anObject : list){ //do someting to anObject... } </pre> <p>如果没有泛型，上面的例子应该是这样的:</p> <pre class="codeBox"> List list = new ArrayList(); //no generic type specified list.add(new MyObject("First MyObject")); MyObject myObject = (MyObject) list.get(0); //cast needed for(Object anObject : list){ //cast needed MyObject theMyObject = (MyObject) anObject; //do someting to anObject... } </pre> <p>请注意将从列表中检索到的 MyObject 实例转换为 MyObject 是多么必要。如果没有在列表变量声明中设置泛型类型，Java 编译器只知道列表包含对象实例。因此，您需要将它们转换为您知道该对象所属的具体类(或接口)。</p> <p>尽可能为列表变量指定一个泛型类型是一个好习惯。它帮助您避免将错误类型的对象插入列表。它使您能够从列表中检索对象，而不必将它们转换为实际类型。它帮助你的代码的读者看到列表应该包含什么类型的对象。只有在有充分理由的情况下，才应该省略泛型类型。</p> <p>在本 Java List 教程的剩余部分，我将尽可能多地使用通用列表示例。</p> <p>关于 Java 泛型的更多信息，请参见<a href="/java-generics/index.html"> Java 泛型教程</a>。</p> <h2>在 Java 列表中插入元素</h2> <p>使用 Java 的<code>add()</code>方法将元素(对象)插入到 Java <code>List</code>中。下面是一个使用<code>add()</code>方法向 Java <code>List</code>添加元素的例子:</p> <pre class="codeBox"> List&lt;String&gt; listA = new ArrayList&lt;&gt;(); listA.add("element 1"); listA.add("element 2"); listA.add("element 3"); </pre> <p>前三个<code>add()</code>调用将一个<code>String</code>实例添加到列表的末尾。</p> <h3>插入空值</h3> <p>实际上可以将<code>null</code>值插入到 Java <code>List</code>中。下面是一个将<code>null</code>值插入 Java <code>List</code>的例子:</p> <pre class="codeBox"> Object element = null; List&lt;Object&gt; list = new ArrayList&lt;&gt;(); list.add(element); </pre> <h3>在特定索引处插入元素</h3> <p>可以在 Java <code>List</code>的特定索引处插入一个元素。<code>List</code>接口有一个版本的<code>add()</code>方法，它将索引作为第一个参数，将要插入的元素作为第二个参数。下面是一个将索引 0 处的元素插入 Java <code>List</code>的例子:</p> <pre class="codeBox"> list.add(0, "element 4"); </pre> <p>如果<code>List</code>已经包含了元素，那么这些元素将会在<code>List</code>的内部序列中被下推。在新元素被插入到索引 0 之前具有索引 0 的元素将被推到索引 1，依此类推。</p> <h2>将一个列表中的所有元素插入另一个列表</h2> <p>可以将一个 Java <code>List</code>中的所有元素添加到另一个<code>List</code>中。你可以使用<code>List</code>和<code>addAll()</code>的方法。由此产生的<code>List</code>是两个列表的<em>并集</em>。以下是将一个<code>List</code>中的所有元素添加到另一个中的示例:</p> <pre class="codeBox"> List&lt;String&gt; listSource = new ArrayList&lt;&gt;(); listSource.add("123"); listSource.add("456"); List&lt;String&gt; listDest = new ArrayList&lt;&gt;(); listDest.addAll(listSource); </pre> <p>此示例将所有元素从<code>listSource</code>添加到<code>listDest</code>。</p> <p><code>addAll()</code>方法接受一个<code>Collection</code>作为参数，因此您可以传递一个<code>List</code>或<a href="set.html"> Java Set </a>作为参数。换句话说，你可以用<code>addAll()</code>将<code>List</code>或<code>Set</code>中的所有元素添加到<code>List</code>中。</p> <h2>从 Java 列表中获取元素</h2> <p>您可以使用元素的索引从 Java <code>List</code>中获取元素。您可以使用<code>get(int index)</code>方法来完成。下面是一个使用元素索引访问 Java <code>List</code>元素的例子:</p> <pre class="codeBox"> List&lt;String&gt; listA = new ArrayList&lt;&gt;(); listA.add("element 0"); listA.add("element 1"); listA.add("element 2"); //access via index String element0 = listA.get(0); String element1 = listA.get(1); String element3 = listA.get(2); </pre> <p>也可以按照内部存储的顺序迭代 Java <code>List</code>的元素。在本 Java List 教程的后面，我将向您展示如何做到这一点。</p> <h2>在列表中查找元素</h2> <p>您可以使用以下两种方法之一在 Java <code>List</code>中找到元素:</p> <ul> <li>indexOf()</li> <li>lastIndexOf()</li> </ul> <p><code>indexOf()</code>方法查找给定元素在<code>List</code>中第一次出现的索引。下面是一个在 Java <code>List</code>中查找两个元素的索引的例子:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); String element1 = "element 1"; String element2 = "element 2"; list.add(element1); list.add(element2); int index1 = list.indexOf(element1); int index2 = list.indexOf(element2); System.out.println("index1 = " + index1); System.out.println("index2 = " + index2); </pre> <p>运行此代码将产生以下输出:</p> <pre class="codeBox"> index1 = 0 index2 = 1 </pre> <h3>查找列表中最后一个出现的元素</h3> <p><code>lastIndexOf()</code>方法查找给定元素在<code>List</code>中最后一次出现的索引。下面的例子展示了如何在 Java <code>List</code>中找到给定元素最后一次出现的索引:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); String element1 = "element 1"; String element2 = "element 2"; list.add(element1); list.add(element2); list.add(element1); int lastIndex = list.lastIndexOf(element1); System.out.println("lastIndex = " + lastIndex); </pre> <p>运行上述 Java 示例的输出将是:</p> <pre class="codeBox"> lastIndex = 2 </pre> <p>元素<code>element 1</code>在<code>List</code>中出现 2 次。最后一次出现的索引是 2。</p> <h2>检查列表是否包含元素</h2> <p>您可以使用<code>List</code> <code>contains()</code>方法检查 Java <code>List</code>是否包含给定的元素。下面是一个使用<code>contains()</code>方法检查 Java <code>List</code>是否包含元素的例子:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); String element1 = "element 1"; list.add(element1); boolean containsElement = list.contains("element 1"); System.out.println(containsElement); </pre> <p>运行这个 Java <code>List</code>示例的输出将是:</p> <pre class="codeBox"> true </pre> <p>...因为<code>List</code>实际上包含了元素。</p> <p>为了确定<code>List</code>是否包含元素，<code>List</code>将在内部迭代它的元素，并将每个元素与作为参数传递的对象进行比较。比较使用元素的<a href="hashcode-equals.html"> Java equals </a>方法来检查元素是否等于参数。</p> <p>因为可以将<code>null</code>值加到<code>List</code>上，所以实际上可以检查<code>List</code>是否包含<code>null</code>值。下面是如何检查一个<code>List</code>是否包含一个<code>null</code>值:</p> <pre class="codeBox"> list.add(null); containsElement = list.contains(null); System.out.println(containsElement); </pre> <p>显然，如果<code>contains()</code>的输入参数是<code>null</code>,<code>contains()</code>方法不会使用<code>equals()</code>方法来比较每个元素，而是使用<code>==</code>操作符。</p> <h2>从 Java 列表中删除元素</h2> <p>您可以通过以下两种方法从 Java <code>List</code>中移除元素:</p> <ol> <li>移除(对象元素)</li> <li>移除(整数索引)</li> </ol> <p>删除列表中的元素，如果它存在的话。然后，列表中的所有后续元素在列表中上移。他们的指数因此减少了 1。下面是一个基于元素本身从 Java <code>List</code>中删除元素的例子:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); String element = "first element"; list.add(element); list.remove(element); </pre> <p>这个例子首先向一个<code>List</code>添加一个元素，然后再次删除它。</p> <p><code>List</code> <code>remove(int index)</code>方法删除给定索引处的元素。然后，列表中的所有后续元素在列表中上移。他们的指数因此减少了 1。下面是一个通过索引从 Java <code>List</code>中删除元素的例子:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("element 0"); list.add("element 1"); list.add("element 2"); list.remove(0); </pre> <p>运行这个 Java 示例代码后，<code>List</code>将包含索引 0 和 1 处的<a href="/java/strings.html"> Java 字符串</a>元素<code>element 1</code>和<code>element 2</code>。第一个元素(<code>element 0</code>)已经从<code>List</code>中移除。</p> <h2>从 Java 列表中移除所有元素</h2> <p>Java <code>List</code>接口包含一个<code>clear()</code>方法，该方法在被调用时从列表中删除所有元素。从<code>List</code>中移除所有元素也被称为<em>清除</em>和<code>List</code>。下面是用<code>clear()</code>方法从<code>List</code>(清除)中移除所有元素的简单示例:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("object 1"); list.add("object 2"); //etc. <b>list.clear();</b> </pre> <p>首先，创建一个新的<code>List</code>。其次，两个元素被添加到<code>List</code>中。第三，调用<code>clear()</code>方法。在调用了<code>clear()</code>方法之后，<code>List</code>将完全为空。</p> <h2>将一个列表中的所有元素保留在另一个列表中</h2> <p>Java <code>List</code>接口有一个名为<code>retainAll()</code>的方法，它能够保留一个<code>List</code>中的所有元素，这些元素也存在于另一个<code>List</code>中。换句话说，<code>retain()</code>方法从目标<code>List</code>中移除所有在另一个<code>List</code>中没有的元素。得到的<code>List</code>是两个列表的<em>交集</em>。下面是一个调用<code>List</code> <code>retainAll()</code>方法的 Java 示例:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; otherList = new ArrayList&lt;&gt;(); String element1 = "element 1"; String element2 = "element 2"; String element3 = "element 3"; String element4 = "element 4"; list.add(element1); list.add(element2); list.add(element3); otherList.add(element1); otherList.add(element3); otherList.add(element4); list.retainAll(otherList); </pre> <p>首先创建两个列表。其次，<code>list</code>增加 3 个元素，<code>otherList</code>增加 3 个元素。第三，在<code>list</code>上调用<code>retainAll()</code>方法，将<code>otherList</code>作为参数传递。在<code>list.retainAll(otherList)</code>执行完毕后，<code>list</code>将只包含那些在<code>retainAll()</code>被调用之前在<code>list</code>和<code>otherList</code>中都存在的元素。更确切的说，那就是<code>element1</code>和<code>element3</code>。</p> <h2>列表大小</h2> <p>您可以通过调用<code>size()</code>方法来获得<code>List</code>中元素的数量。这里有一个例子:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("object 1"); list.add("object 2"); int size = list.size(); </pre> <h2>列表的子列表</h2> <p>Java <code>List</code>接口有一个名为<code>subList()</code>的方法，它可以用原始<code>List</code>中的元素子集创建一个新的<code>List</code>。</p> <p><code>subList()</code>方法有两个参数:开始索引和结束索引。起始索引是原始<code>List</code>中要包含在子列表中的第一个元素的索引。结束索引是子列表的最后一个索引，但是最后一个索引处的元素不包含在子列表中。这类似于<a href="/java/strings.html#substring"> Java String substring </a>方法的工作方式。</p> <p>下面是一个使用<code>subList()</code>方法从另一个<code>List</code>创建元素子列表的 Java 示例:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("element 1"); list.add("element 2"); list.add("element 3"); list.add("element 4"); List&lt;String&gt; sublist = list.subList(1, 3); </pre> <p>执行完<code>list.subList(1,3)</code>指令后，<code>sublist</code>将包含索引 1 和 2 处的元素。记住，原始列表有 4 个元素，索引从 0 到 3。<code>list.subList(1,3)</code>调用将包括索引 1，但排除索引 3，从而保持元素在索引 1 和 2。</p> <h2>将列表转换为集合</h2> <p>您可以通过创建一个新的<code>Set</code>并将<code>List</code>中的所有元素添加到其中，将 Java <code>List</code>转换成 Java <code>Set</code>。<code>Set</code>将删除所有重复的内容。因此，得到的<code>Set</code>将包含来自<code>List</code>的所有元素，但只包含一次。下面是一个将 Java <code>List</code>转换成<code>Set</code>的例子:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("element 1"); list.add("element 2"); list.add("element 3"); list.add("element 3"); Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(list); </pre> <p>请注意，<code>List</code>包含了字符串<code>element 3</code>两次。<code>Set</code>将只包含该字符串一次。因此，结果集将包含字符串<code>element 1</code>、<code>element 2</code>和<code>element 3</code>。</p> <h2>将列表转换为数组</h2> <p>您可以使用<code>List</code> <code>toArray()</code>方法将一个 Java <code>List</code>转换成一个<a href="/java/arrays.html"> Java 数组</a>。下面是一个将 Java <code>List</code>转换成 Java 数组的例子:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("element 1"); list.add("element 2"); list.add("element 3"); list.add("element 3"); Object[] objects = list.toArray(); </pre> <p>也可以将<code>List</code>转换成特定类型的数组。下面是一个将 Java <code>List</code>转换成特定类型数组的例子:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("element 1"); list.add("element 2"); list.add("element 3"); list.add("element 3"); String[] objects1 = list.toArray(new String[0]); </pre> <p>注意，即使我们将大小为 0 的字符串数组传递给<code>toArray()</code>，返回的数组也将包含<code>List</code>中的所有元素。它将拥有与<code>List</code>相同数量的元素。</p> <h2>将数组转换为列表</h2> <p>也可以将 Java <code>List</code>转换成数组。下面是一个将 Java 数组转换成<code>List</code>的例子:</p> <pre class="codeBox"> String[] values = new String[]{ "one", "two", "three" }; List&lt;String&gt; list = (List&lt;String&gt;) Arrays.asList(values); </pre> <p>是<code>Arrays.asList()</code>方法将数组转换为<code>List</code>。</p> <h2>排序列表</h2> <p>您可以使用<code>Collections</code> <code>sort()</code>方法对 Java <code>List</code>进行排序。我已经在我的<a href="sorting.html">排序 Java 集合教程</a>中解释了它是如何工作的，但是在接下来的章节中我将只向你展示几种排序 Java 的方法<code>List</code>。</p> <h3>可比较对象的排序列表</h3> <p>如果<code>List</code>包含实现<code>Comparable</code>接口(<code>java.lang.Comparable</code>)的对象，那么这些对象可以相互比较。在这种情况下，您可以像这样对<code>List</code>进行排序:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("c"); list.add("b"); list.add("a"); Collections.sort(list); </pre> <p>Java <code>String</code>类实现了<code>Comparable</code>接口，你可以使用<code>Collections</code> <code>sort()</code>方法将它们按自然顺序排序。</p> <h3>使用比较器排序列表</h3> <p>如果 Java <code>List</code>中的对象没有实现<code>Comparable</code>接口，或者如果您想以不同于它们的<code>compare()</code>实现的另一种顺序对对象进行排序，那么您需要使用一个<code>Comparator</code>实现(<code>java.util.Comparator</code>)。下面是一个使用<code>Comparator</code>对<code>Car</code>对象列表进行排序的例子。这里首先是<code>Car</code>类:</p> <pre class="codeBox"> public class Car{ public String brand; public String numberPlate; public int noOfDoors; public Car(String brand, String numberPlate, int noOfDoors) { this.brand = brand; this.numberPlate = numberPlate; this.noOfDoors = noOfDoors; } } </pre> <p>下面是对上述<code>Car</code>对象的 Java <code>List</code>进行排序的代码:</p> <pre class="codeBox"> List&lt;Car&gt; list = new ArrayList&lt;&gt;(); list.add(new Car("Volvo V40" , "XYZ 201845", 5)); list.add(new Car("Citroen C1", "ABC 164521", 4)); list.add(new Car("Dodge Ram" , "KLM 845990", 2)); Comparator&lt;Car&gt; carBrandComparator = new Comparator&lt;Car&gt;() { @Override public int compare(Car car1, Car car2) { return car1.brand.compareTo(car2.brand); } }; Collections.sort(list, carBrandComparator); </pre> <p>注意上面例子中的<code>Comparator</code>实现。这个实现只比较<code>Car</code>对象的<code>brand</code>字段。可以创建另一个<code>Comparator</code>实现来比较汽车的车牌，甚至是门的数量。</p> <p>还要注意，使用一个<a href="/java/lambda-expressions.html"> Java Lambda </a>来实现一个<code>Comparator</code>是可能的。下面是一个例子，它使用<code>Comparator</code>接口的三种不同的 Java lambda 实现对<code>Car</code>对象的<code>List</code>进行排序，每种实现都通过不同的字段比较<code>Car</code>实例:</p> <pre class="codeBox"> List&lt;Car&gt; list = new ArrayList&lt;&gt;(); list.add(new Car("Volvo V40" , "XYZ 201845", 5)); list.add(new Car("Citroen C1", "ABC 164521", 4)); list.add(new Car("Dodge Ram" , "KLM 845990", 2)); Comparator&lt;Car&gt; carBrandComparatorLambda = (car1, car2) -&gt; car1.brand.compareTo(car2.brand); Comparator&lt;Car&gt; carNumberPlatComparatorLambda = (car1, car2) -&gt; car1.numberPlate.compareTo(car2.numberPlate); Comparator&lt;Car&gt; carNoOfDoorsComparatorLambda = (car1, car2) -&gt; car1.noOfDoors - car2.noOfDoors; Collections.sort(list, carBrandComparatorLambda); Collections.sort(list, carNumberPlatComparatorLambda); Collections.sort(list, carNoOfDoorsComparatorLambda); </pre> <h2>迭代列表</h2> <p>您可以用几种不同的方式迭代 Java <code>List</code>。三种最常见的方式是:</p> <ul> <li>使用<code>Iterator</code></li> <li>使用 for-each 循环</li> <li>使用 for 循环</li> <li>使用 Java 流 API</li> </ul> <p>我将在接下来的章节中解释这些迭代 Java <code>List</code>的方法。</p> <h3>使用迭代器迭代列表</h3> <p>迭代一个<code>List</code>的第一种方法是使用一个<a href="iterator.html"> Java 迭代器</a>。下面是一个用<code>Iterator</code>迭代<code>List</code>的例子:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("first"); list.add("second"); list.add("third"); Iterator&lt;String&gt; iterator = list.iterator(); while(iterator.hasNext()) { String next = iterator.next(); } </pre> <p>您通过调用<code>List</code>接口的<code>iterator()</code>方法获得一个<code>Iterator</code>。</p> <p>一旦你获得了一个<code>Iterator</code>，你可以继续调用它的<code>hasNext()</code>方法，直到它返回<code>false</code>。如你所见，调用<code>hasNext()</code>是在一个<code>while</code>循环中完成的。</p> <p>在<code>while</code>循环中，您调用<code>Iterator</code>接口的<code>Iterator</code> <code>next()</code>方法来获取由<code>Iterator</code>指向的下一个元素。</p> <p>如果使用<a href="/java-generics/index.html"> Java 泛型</a>对<code>List</code>进行类型化，你可以在<code>while</code>循环中保存一些对象转换。这里有一个例子:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("first"); list.add("second"); list.add("third"); Iterator&lt;String&gt; iterator = list.iterator(); while(iterator.hasNext()){ String obj = iterator.next(); } </pre> <h3>使用 For-Each 循环迭代列表</h3> <p>迭代<code>List</code>的第二种方法是使用 Java 5 中添加的<code>for</code>循环(也称为“for each”循环)。下面是一个使用<code>for</code>循环迭代<code>List</code>的例子:</p> <pre class="codeBox"> List list = new ArrayList(); list.add("first"); list.add("second"); list.add("third"); for(Object element : list) { System.out.println(element); } </pre> <p><code>for</code>循环对<code>List</code>中的每个元素执行一次。在<code>for</code>循环中，每个元素依次绑定到<code>obj</code>变量。</p> <p>如果列表是类型化的(一个<i>泛型</i> <code>List</code>)，你可以在<code>for</code>循环中改变变量的类型。下面是键入的<code>List</code>迭代示例:</p> <pre class="codeBox"> List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //add elements to list for(String element : list) { System.out.println(element); } </pre> <p>注意<code>List</code>是如何被输入到<code>String</code>的。因此，您可以将<code>for</code>循环中的变量类型设置为<code>String</code>。</p> <h3>使用 For 循环迭代列表</h3> <p>迭代<code>List</code>的第三种方法是使用标准的<code>for</code>循环，如下所示:</p> <pre class="codeBox"> List list = new ArrayList(); list.add("first"); list.add("second"); list.add("third"); for(int i=0; i &lt; list.size(); i++) { Object element = list.get(i); } </pre> <p><code>for</code>循环创建一个<code>int</code>变量并将其初始化为 0。然后，只要 int 变量<code>i</code>小于列表的大小，它就会循环。对于每次迭代，变量<code>i</code>递增。</p> <p>在<code>for</code>循环中，该示例通过其<code>get()</code>方法访问<code>List</code>中的元素，并将递增变量<code>i</code>作为参数传递。</p> <p>同样，如果使用 Java 泛型将<code>List</code>类型化为例如<code>String</code>，那么您可以使用<code>List</code>的泛型类型作为局部变量的类型，该变量在迭代过程中被分配给<code>List</code>中的每个元素。一个例子将使这一点更加清楚:</p> <pre class="codeBox"> List<b>&lt;String&gt;</b> list = new ArrayList<b>&lt;String&gt;</b>(); list.add("first"); list.add("second"); list.add("third"); for(int i=0; i &lt; list.size(); i++) { <b>String</b> element = list.get(i); } </pre> <p>注意<code>for</code>循环中的局部变量类型现在是<code>String</code>。因为<code>List</code>一般被类型化为<code>String</code>，所以它只能包含<code>String</code>对象。因此，编译器知道只有一个<code>String</code>可以从<code>get()</code>方法返回。因此，您不需要将由<code>get()</code>返回的元素强制转换为<code>String</code>。</p> <h3>使用 Java 流 API 迭代列表</h3> <p>迭代 Java <code>List</code>的第四种方式是通过<a href="/java-functional-programming/streams.html"> Java Stream </a> API。要迭代一个 Java <code>List</code>，你必须首先从<code>List</code>获得一个<code>Stream</code>。从 Java 中的<code>List</code>获取一个<code>Stream</code>是通过调用<code>List</code> <code>stream()</code>方法来完成的。下面是一个从 Java <code>List</code>获得 Java <code>Stream</code>的例子:</p> <pre class="codeBox"> List&lt;String&gt; stringList = new ArrayList&lt;String&gt;(); stringList.add("abc"); stringList.add("def"); Stream&lt;String&gt; stream = stringList.stream(); </pre> <p>这个例子的最后一行调用了<code>List</code> <code>stream()</code>方法来获得代表<code>List</code>中元素的<code>Stream</code>。</p> <p>一旦从<code>List</code>中获得了<code>Stream</code>，就可以通过调用<code>forEach()</code>方法来迭代<code>Stream</code>。下面是一个使用<code>Stream</code> <code>forEach()</code>方法迭代<code>List</code>元素的例子:</p> <pre class="codeBox"> List&lt;String&gt; stringList = new ArrayList&lt;String&gt;(); stringList.add("one"); stringList.add("two"); stringList.add("three"); Stream&lt;String&gt; stream = stringList.stream(); stream .forEach( element -&gt; { System.out.println(element); }); </pre> <p>调用<code>forEach()</code>方法将使<code>Stream</code>内部迭代<code>Stream</code>的所有元素，并为<code>Stream</code>中的每个元素调用作为参数传递给<code>forEach()</code>方法的<code>Consumer</code>。</p> <p>你可以在我的<a href="/java-functional-programming/streams.html"> Java 流 API 教程</a>中阅读更多关于通过 Java 流 API 处理<code>List</code>元素的不同选项。</p> <h2>Java List JavaDoc 中的更多细节</h2> <p>使用 Java <code>List</code>可以做更多的事情，但是您必须查看 JavaDoc 以获得更多的细节。本文主要关注两个最常见的操作:添加/删除元素和迭代元素。</p> </body> </html></iframe>