# RION 与其他格式

> 原文:[https://jen kov . com/tutorials/rion/rion-vs-other-formats . html](https://jenkov.com/tutorials/rion/rion-vs-other-formats.html)

本文讨论了 RION 如何不同于其他数据格式，以解决紧凑的二进制数据通信的相同问题。我们将 RION 比作:

*   原蟾蜍
*   CBOR
*   消息包
*   JSON

这里有一个总结这些差异的表格。“是(*)”表示“是-但有限制”。“否(*)”表示“否，但可以弯曲以支撑它”。如果这张表上有什么不对的地方，请告诉我们！

| 特征 | 里奥 | CBOR | 消息包 | 原蟾蜍 | JSON |
| Raw bytes | 是 | 是 | 是 | 是 | 否(*) |
| 有效原始字节 | 是 | 是 | 是 | 是 | 否 |
| 布尔代数学体系的 | 是 | 是 | 是 | 是 | 是 |
| （同 Internationalorganizations）国际组织 | 是 | 是 | 是 | 是 | 是 |
| 漂浮物 | 是 | 是 | 是 | 是 | 是 |
| UTF-8 | 是 | 是 | 是 | 是 | 是 |
| UTC-日期-时间 | 是 | 是 | 是 | 否 | 否 |
| (早期数据的)拷贝 | 是(*) | 否 | 否 | 否 | 否 |
| 对象/地图 | 是 | 是 | 是 | 是 | 是 |
| 排列 | 是 | 是 | 是 | 是 | 是 |
| 桌子 | 是 | 否 | 否 | 否 | 否 |
| 模式/类 Id | 是(*) | 否 | 否 | 否 | 否 |
| 循环引用 | 是(*) | 否 | 否 | 否 | 否 |
| 缓存引用 | 是(*) | 否 | 否 | 否 | 否 |
| 未指定长度的数组/映射 | 否 | 是 | 否 | ? | 是 |
| 任意层次导航 | 是 | 是(*) | 是(*) | 是 | 是(*) |
| 流模式阅读 | 是 | 是 | 是 | 是 | 是 |
| 流模式写入 | 是(*) | 是 | 是(*) | 是 | 是 |
| 自我描述 | 是 | 是(*) | 是(*) | 否 | 是(*) |
| 可扩展新的/自定义类型 | 是 | 是 | 是 | 是 | 否 |

在这些格式中，RION 与 CBOR 最为相似。RION 也非常类似于 MessagePack(尽管不如 CBOR)。基本编码是如此的相似，以至于这些格式对于字段应该有相当的读写速度。RION 性能基准测试证实了这一点。

RION 与 CBOR 和 MessagePack 的主要区别是表数据结构。该表可以模拟类似于 CSV 文件或数据库表的表格数据。RION 表只包含一次列名，后面是表中所有行的列值。表也可以包含嵌套表，因此表也可以用于使对象图更紧凑(其中一个父对象可以有多个同类的子对象)。

表是发送同类对象数组的一种非常简洁的方式。基准测试还显示，RION 表可以减少到 JSON 编码数据的 33-25%(CBOR 和 MessagePack 的 40-50%)。

并非所有格式都很好地支持原始字节。我说的原始字节是指一个字节序列，比如一个文件，或者一个视频帧等等。要在 JSON 中包含原始字节，它们必须使用 Base64 或 Hex 编码进行文本编码。Base64 编码会使编码数据占用原数据的 4/3(多三分之一)，Hex 编码会使编码数据占用原数据的两倍。RION，MessagePack，CBOR 和 Protobuf 没有问题，包括原始字节。

RION 和 CBOR 都支持 UTC 日期时间，但是 RION 的日期时间编码使用的字节比 CBOR 使用的 ISO 标准(文本)格式少 50%。另外，RION 只支持 UTC 时间，而不支持本地时间(尽管您需要自己在 UTC 之间进行转换)。

RION 最终将包含一个特殊的“复制”字段，该字段使您能够引用同一 RION 数据中较早的一个 RION 字段，该字段应被复制到 RION 数据中的该位置。不过，这个字段的确切定义已经被推迟到以后的版本中。例如，Copy 字段可以用来复制一个类名(见后面)、一个更长的属性名、一个 zip + city 对象、一个大的对象图、表或其他东西。据我们所知，CBOR 和 MessagePack 可以使用特殊的“字符串反向引用”元素，该元素可用于引用经常使用的字符串(例如同类对象的属性名)，但它们不是其核心编码的一部分(据我们所知)。

所有格式都支持编码数据的任意层次导航，而无需先将其转换为对象。然而，由于 RION 总是知道复杂字段(包含其他字段的字段，如对象、数组或表)的确切字节大小，RION 可以跳过整个字段，而不必解析其嵌套字段。CBOR、MessagePack 和 JSON 做不到这一点。它们都需要对一个字段的内容进行某种程度的解析，以便在同一层次上找到它后面的下一个元素(下一个兄弟)。

RION、CBOR、MessagePack 和 JSON 都是自描述的，这意味着你不需要外部模式来阅读它们。这对于中间节点可能必须将消息路由到其他节点的网络协议来说至关重要。根据 Protobuf 自己的文档，你看不到一条 Protobuf 消息的结束和下一条消息的开始，这意味着 Protobuf 不是完全自描述的。您可以看到各个 Protobuf 字段的开始和结束位置，但不能看到完整的消息。

Protobuf 不是完全自描述的事实使它不适合作为网络协议消息格式(尽管您可以在其他类型的消息中路由 Protobuf 消息)。数据格式是自描述的，这也意味着可以将这些格式的文件转换成文本格式(JSON 已经是文本格式了)，以查看文件中实际存储了什么。

将来，RION 将支持多种级别的自描述消息。在最具描述性的层面上，RION 可以在对象、数组或表中嵌入模式或类名(复杂类型 id)。这当然会占用更多的空间。您也可以根据较短的数字或文本代码嵌入一个短的模式/类 id，然后在读取 RION 消息时翻译它。但是，尚未指定模式/类 ID 字段。

就 RION 而言，模式/类名在任何情况下都是可选的。你也可以像 JSON 一样用键+值对来序列化对象。RION 也支持这一点。事实上，CBOR、MessagePack 和 JSON 也支持这种级别的自描述消息。一个微小的区别是 RION 在发送空值时保持数据类型(例如，空 int-64 或空 UTF-8 文本)。CBOR、MessagePack 和 JSON 在传递空值时都会丢失类型。空值没有类型。(但正如所说——他的并不是什么大事)。

RION 还支持省略了属性名的紧凑级对象。这非常类似于 RION 表的工作方式，其中对象的属性名只列出一次。对象和表的紧凑级别使得 RION 非常类似于 Protobuf 的编码方式。因此，这种编码模式也符合 Protobuf 的性能(比 Protobuf 写得更快，但读得更慢)。即使这些紧凑对象不包含任何属性名，它们仍然足够自描述，以至于您可以看到字段的开始和结束位置，以及它们的数据类型，而无需外部模式。你不能用 Protobuf 做到这一点(据我们所知)。

RION 最终将获得在对象间表达循环引用的支持。此时，对对象引用的支持还没有完成。

RION 被设计为 IAP 网络协议的网络消息格式(以及其他格式)。我们计划在 IAP 中构建的一个特性是缓存与 IAP 连接相关的数据。例如，web 服务器可以要求客户端缓存文件。或者，API 服务器可以要求客户端缓存一些它经常返回的数据(例如服务状态)。在会话的后期，服务器可以引用这个缓存文件(实际上是任何 RION 字段)作为它发送的新消息的一部分。

与 CBOR 相比，RION 最大的缺点是 CBOR 允许流模式写数组和对象。在流模式编写中，元素在开始时不包含关于对象或数组有多大的信息。相反，对象或数组有一个结束标记。这种流模式写入允许生成 CBOR 数据并直接在网络上流出。

因为 RION 字段都在字段的开头包含字段的字节大小，所以只有在事先知道字段的大小时，才能对 RION 使用流模式写入。对于原始字段(例如 string 或 int-64)来说通常是这样，甚至对于从磁盘中读取的文件来说也是这样，因为您事先知道文件的大小。但是对于基于例如数据库查询生成的较大对象，流模式写入是不可能的。在发送之前，你必须先把信息缓冲一下。这可以相当有效地完成，所以这对于较大的消息(4K 及以上)最明显。

请记住，来自磁盘的文件通常比 4K 大，仍然可以使用 RION 的流模式写入，因此这只是大量生成数据的问题(例如，从模板中组合的 HTML 文件等)。).但是，我们计划在 IAP 的其他地方解决这些问题。

在 RION 中完全可以进行流模式读取。