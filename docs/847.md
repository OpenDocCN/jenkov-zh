# 服务交易

> 原文:[https://jenkov.com/tutorials/soa/service-transactions.html](https://jenkov.com/tutorials/soa/service-transactions.html)

服务偶尔需要参与事务。这样做是为了确保业务逻辑正确执行，或者在某个服务失败时完全取消。让我们来看一个经典的例子:

银行应用程序需要将资金从一个帐户转移到另一个帐户。目前，银行系统有两项服务:

*   存款服务
*   取款服务

下面是银行系统的一个例子:

<center>

| ![Service Transactions - a simple bank application using two services](../Images/cb870bb60aeea03cf7ef74377bfa45bb.png) |
| 服务交易——使用两种服务的简单银行应用程序。 |

</center>

为了将钱从一个帐户转移到另一个帐户，银行应用程序需要调用取款服务和存款服务。例如，首先从账户 A 提取 100 美元，然后将这 100 美元存入账户 b。

如果由于某种原因，两个服务调用中的一个失败了，那么银行系统将会以不一致的状态结束。如果银行系统首先调用取款服务，而存款服务调用失败，那么 100 美元将被取出，而没有被存入任何地方。在网络空间损失了 100 美元。另一方面，如果存款服务首先被调用，然后取款服务失败，那么$100 将已经被存入而没有从任何账户中被取出。100 美元是凭空创造出来的。

这个问题的解决方案是将取款和存款服务调用作为单个原子操作来执行。这就是交易的目的。

## 作为原子操作的事务

一个事务将一个或多个动作组合在一起，并确保它们就像一个动作一样被执行。如果其中一个操作失败，所有操作都会失败。只有当所有操作成功时，操作的结果才会被“提交”(永久存储)到系统中。

下面是被分组到一个事务中的取款和存款服务的图示:

<center>

| ![Service Transactions - two services grouped into a single transaction](../Images/33d320db49ca51204c247d59d4975850.png) |
| **服务交易——两个服务组合成一个交易。** |

</center>

## 两阶段提交事务

需要协调参与事务的服务，以确保在该事务中，要么所有被调用的服务“提交”它们的动作，要么没有。协调这种分布式事务的一种流行方法是“两阶段提交”协议。

两阶段提交协议包括三个步骤:

1.  开始交易
2.  准备阶段
3.  提交阶段

首先，所有参与者都被告知要参与交易。从这一点开始，每个参与者执行的与该交易相关的所有操作都必须作为一个操作来执行(全部或无)。动作还不能提交给主系统，但是必须保存在参与者(服务)的内部，直到参与者被指示提交动作。

第二，一旦所有参与者成功地执行了所有动作，所有参与者(例如服务)被命令进入“准备阶段”。一旦参与者成功进入准备阶段，参与者必须保证在事务内部执行的所有操作都准备好提交。如果参与者在成功进入准备阶段后失败，那么一旦参与者再次正常工作，它必须能够提交操作。换句话说，在事务内部执行的动作必须能够在参与者崩溃/重启时仍然存在。这通常是通过将事务日志写入持久介质(如硬盘)来完成的。

如果其中一个参与者不能进入准备阶段，所有参与者都被命令回滚(中止)事务。

如果所有参与者都成功地进入准备阶段，那么所有参与者现在都被命令提交他们的动作。一旦提交，动作就在系统中可见，并被永久执行。

### 两阶段提交弱点

两阶段提交协议不是 100%安全的。想象一下，如果服务在进入准备阶段后崩溃了。现在，所有服务都被请求提交。假设失败的服务是链中被命令提交的最后一个服务。但是提交顺序失败了，因为服务崩溃了。该事务中的所有其他服务都已经提交了它们的操作，但最后一个服务没有提交。

通常，一旦服务再次运行，服务就必须提交它的事务的一部分。但是，如果服务再也没有恢复，那该怎么办呢？它的动作没有被提交，那么系统的状态是什么？

下面是一个两阶段提交事务的示例，其中最后一个服务未能提交:

<center>

| ![Service Transactions - A two phase commit transaction failing](../Images/6362d278472b3d2abdd30b733176aeef.png) |
| **服务事务-两阶段提交事务失败。** |

</center>

## 交易协调

当多个服务参与一个事务时，某个实体必须协调该事务。换句话说，必须有人指出事务何时开始，以及何时进入准备和提交阶段。这个实体，即事务协调器，可以是:

*   应用程序
*   一条[企业服务总线](esb.html)
*   独立的事务管理器/服务

在本文前面的示例中，应用程序协调事务。

## 每笔交易一项服务

在面向服务的体系结构中，简化事务管理的一种方法是设计服务，使每个事务都包含在一个服务中。例如，在本文开头的示例中，货币转账将作为单独的服务来实现，而不是包含两个服务的交易。这是它看起来的样子:

<center>

| ![Service Transactions - Each transaction is contained within its own service](../Images/667716568bc52c0cf24185a27afd9d48.png) |
| 服务事务——每个事务都包含在自己的服务中。 |

</center>