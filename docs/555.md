# Java 性能

> 原文:[https://jenkov.com/tutorials/java-performance/index.html](https://jenkov.com/tutorials/java-performance/index.html)

Java 性能调优在某种程度上是一门黑色艺术。很难找到关于 Java 性能调优的好信息，原因有几个。

首先，性能调优在很大程度上取决于您正在构建的系统和系统运行的硬件。随着时间的推移，您的系统、Java 虚拟机和执行您的系统的硬件都会发生变化。随着这种发展，适用的 Java 性能技术也随之发展。

第二，我们 Java 开发者被灌输了许多关于 Java 编译器和 Java 虚拟机的不真实的故事。人们常说，Java 编译器或 VM 在优化代码方面比你做得更好。

然而，这并不总是完全正确的。算法、数据格式、数据结构、内存使用模式、IO 使用模式等。事！在许多情况下，您可以比 Java 编译器和 JVM 更好地优化您的代码，因为您更了解您的系统试图做什么、它的数据结构、数据使用模式等等。比 Java 更好。

请注意:这个 Java 性能教程是一个多页的教程。这一页只是介绍！

## 主要的表演技巧

Java 开发中有许多不同的性能优化技巧，但它们都属于以下类别之一:

*   减少执行任务所需的工作(操作)。
*   将代码与硬件(CPU、RAM、SSD 等)结合起来。)(又名机械同情)
*   在可能的情况下，尽可能多地并行化任务，并且在有意义的时候。

减少执行给定任务所需的工作(操作)要求您能够想出更快的方法来执行该任务。有时还需要了解 Java 内部发生了什么，一直到硬件层。有时你可以想出一个更紧凑的数据结构，或更快的数据结构，或更快的算法等。这可以加快手头的任务。

将代码与底层硬件的工作方式对齐包括一些技巧，比如在 8 字节地址(0、8、16 等)上对齐变量。)，或者将数据保存在同一个缓存页面中，确保数据彼此靠近存储以利用串行存储器访问，或者减少分支以改善/消除分支预测(以避免 CPU 流水线刷新)，或者知道 SSD 的缓存大小等。

缩短 CPU 和数据之间的距离是使代码和数据与底层硬件工作方式保持一致的一个典型例子。缩短 CPU 与其处理的数据之间的距离通常会加快数据的处理速度。访问 CPU 寄存器内的数据比访问 L1 缓存快，比 L2 缓存快，比 L3 缓存快，比主 RAM 快，比磁盘快，磁盘通常比远程计算机快。

在某些情况下，将一个任务分解成可以并行执行的更小的任务，或者简单地并行执行多个独立的任务也是一种可以显著提高性能的技术。现代 CPU 倾向于获得越来越多的并行执行单元(核心)，因此并行化可以大大提高性能——当有可能以简单的方式分解任务时，或者如果它们已经彼此独立。并行化也可以实现为多台计算机一起工作来解决一个问题，而不是单台计算机。

## 影响性能的方面

任何系统都有几个反复出现的方面会影响其性能。这些方面是:

*   内存管理
*   数据结构
*   算法
*   并发
*   网络通信
*   可量测性

内存管理、数据结构和算法通常紧密联系在一起。某个算法可能需要某个数据结构。某个数据结构可能会影响内存管理。

并发性意味着系统可以在多个线程和 CPU 上很好地分配其负载。并发性也可能与数据结构相关联，但并不总是如此。这取决于您系统的[并发模型](/java-concurrency/concurrency-models.html)。

网络通信也可能影响系统的性能。一些网络协议比另一些更快，有时您可以为自己的特定用例创建一个更快的自定义网络协议。此外，系统的通信模式也会影响性能——不仅仅是消息如何来回传输，还有传输的频率，以及通信是同步还是异步。

系统的可伸缩性意味着当您纵向扩展或横向扩展硬件时，它的性能有多好。纵向扩展意味着购买一台更大的计算机，拥有更大的内存、更多的 CPU、更快的磁盘、网卡等。向外扩展(水平扩展)意味着将系统分布在多台机器上。

## 可重用 Java 性能原则

尽管许多性能优化是针对每个应用程序的，但仍然有一些 Java 性能原则、技术和模式可以在许多不同类型的应用程序和情况中重用。这篇 Java 性能教程将主要关注这些可重用的原则。

我也可能不时地深入到一个特定的系统/用例中，来举例说明这个系统是如何被优化的。这样的例子可能很有启发性，尽管许多公司在谈到可以被认为是竞争优势的东西时倾向于保密。

### 核心 java 性能原则

本教程中的技巧所基于的 Java 性能调优的最常见的核心原则是:

*   内存比磁盘快——快得多——而且内存便宜。
*   当按顺序读取或写入时，所有存储(内存/磁盘)的工作速度最快。任意访问速度较慢。
*   对象分配和垃圾收集很慢。
*   数据格式和数据结构对速度有很大影响。
*   异步 IO 比同步 IO 具有更好的伸缩性。
*   单线程性能是多线程性能的先决条件。
*   共享内存(或磁盘)并发是不好的，因为当系统变得繁忙时，它通常会导致大量争用。

您可能会注意到，本教程中的许多性能技巧都是基于这些相同的原则。

最后一个关于单线程性能的问题可能会让一些人感到惊讶。如今(2015 年)，并行计算和并行编程风靡一时，所以你可能会被告知，你应该考虑将你的问题分解成可以并行解决的更小的问题。不幸的是，没有那么多的问题可以容易地并行化。

此外，如果您的服务器同时处理许多任务(例如，传入的 HTTP 请求)，服务器中的其他 CPU 可能已经在忙于处理它们自己的任务了。并行化任务不会给你带来任何好处，因为 CPU 已经很忙了。事实上，这可能会损害性能(除非您的 CPU 数量远远超过您平均使用的数量)。

## Java 性能学分

这篇 Java 性能教程中介绍的原则和技术不全是我的。实际上，差得很远。这些教程展示了 Java 性能大师们的工作，他们在现实生活中的高性能系统中学习并完善了这些技术。下面是一些 Java 性能大师，他们的工作启发了本 Java 性能教程，或者为本教程做出了贡献(顺序是随机的):

*   [阿列克谢船夫](http://shipilev.net/)
*   [马丁·汤普森](http://mechanical-sympathy.blogspot.de/)
*   [阿苏尔系统公司](http://www.azulsystems.com/)
*   彼得·劳里
*   里克·海托华
*   [心理分析博客](http://psy-lob-saw.blogspot.de/)
*   [高可扩展性博客](http://highscalability.com/)
*   ...更多来了...

我自己的经验来自于 Java 性能实验的混合，以及 VStack.co 的设计和开发，这是一个完全托管的应用程序后端，我和 T2 工作云有限公司共同创建。我们的系统越快，我们能服务的客户就越多、越大、要求也越高。

## Java 性能工具包和基准

本 Java 性能教程中介绍的代码和基准将在将来的某个时候在 GitHub 上发布。代码和基准将位于独立的 GitHub 存储库中。

Java performance toolkit 主要用于展示本教程中提出的思想的实现。它们可能并不总是全功能的——可以在实际应用中使用——但有时可能只是作为一些想法的概念证明。然而，如果你愿意的话，可以在你的应用程序中随意使用这个工具包。

Java 性能基准旨在可以在您自己的硬件上运行，因此您可以看到给定的技术、实现等是如何运行的。在您的特定硬件上运行。

## 感谢反馈

很容易出错——无论是在性能想法、实现还是衡量性能的基准测试中。如果您对这里介绍的想法、实现或基准有任何反馈或建议，我将非常感谢。技术、JVM 和硬件一直在发展。这本 Java 性能教程+实现+基准也应该如此。