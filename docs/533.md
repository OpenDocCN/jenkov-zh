# Java 网络:协议设计

> 原文:[https://jen kov . com/tutorials/Java-networking/protocol-design . html](https://jenkov.com/tutorials/java-networking/protocol-design.html)

如果你正在设计一个客户机-服务器系统，你可能还需要设计一个客户机和服务器之间的通信协议。当然，有时这个协议已经为你决定好了，例如 HTTP，XML-RPC (XML over HTTP)，或者 SOAP(也称为 XML over HTTP)。但是偶尔协议决定是开放的，所以让我们看一些你在设计你的客户机-服务器协议时可能想要考虑的问题:

1.  [客户端-服务器往返](#roundtrips)
2.  [划分请求和响应的结尾](#demarcation)
3.  [穿透防火墙](#firewalls)

## 客户端-服务器往返

当客户端和服务器进行通信以执行某些操作时，它们交换信息。例如，客户机将请求执行一项服务，服务器将尝试执行这项服务，并发回一个响应，告诉客户机结果。客户端和服务器之间的这种信息交换被称为**往返**。

<svg width="100%" height="260"><svg y="10" x="30"><svg x="0" y="0"><text x="30" y="40" style="stroke: none; fill: #000000; font-family: Arial; font-size: 16px; font-weight:bold;">Client</text></svg> <svg x="300" y="0"><text x="20" y="40" style="stroke: none; fill: #000000; font-family: Arial; font-size: 16px; font-weight:bold;">Server</text></svg> <svg x="0" y="50"><text x="140" y="65" style="stroke: none; fill: #000000; font-family: Arial; font-size: 14px; font-weight:bold;">Send Request</text></svg> <svg x="0" y="90"><text x="140" y="65" style="stroke: none; fill: #000000; font-family: Arial; font-size: 14px; font-weight:bold;">Receive Response</text></svg> <text x="120" y="220" style="stroke: none; fill: #000000; font-family: Arial; font-size: 14px; font-weight:bold;">A Client - Server Roundtrip</text></svg></svg>

当一台计算机(客户端或服务器)通过互联网向另一台计算机发送数据时，从发送数据到另一端收到数据需要一段时间。这是数据在互联网上传输所需的时间。这个时间叫做**潜伏期**。

协议中的往返次数越多，协议就变得越慢，尤其是在延迟很高的情况下。HTTP 协议只包含一个请求和一个响应来执行它的服务。换句话说就是一次往返。另一方面，SMTP 协议在发送电子邮件之前，由客户端和服务器之间的多次往返组成。

将您的协议分成多次往返的唯一原因是，如果您有大量数据要从客户端发送到服务器。在这种情况下，您有两种选择:

1.  在单独的往返行程中发送报头信息。
2.  将邮件正文分成小块。

如果服务器能够对例如报头信息进行一些初始预验证，则在单独的往返(第一次)中发送报头可能是聪明的。如果该头信息无效，发送大量数据无论如何都是一种浪费。

如果在传输大量数据时网络连接失败，您可能需要从头开始重新发送所有数据。通过将数据分成更小的块，您只需从网络连接失败的块开始重新发送这些块。成功传输的块不必重新发送。

## 划分请求和响应的结束

如果您的协议允许在同一个连接上发送多个请求，您需要某种方式让服务器知道一个请求何时结束，新的请求何时开始。客户端还需要知道一个响应何时结束，另一个响应何时开始。

您有两个选项来划分请求的结尾:

1.  在请求的开始发送请求的字节长度。
2.  在请求数据之后发送请求结束标记。

HTTP 使用第一种机制。在一个请求报头中，发送“内容长度”。这个头告诉头后面有多少字节属于请求。

这种模型的优点是没有请求结束标记的开销。您也不必对数据体进行编码，以避免数据看起来像请求结束标记。

第一种方法的缺点是发送方必须知道在数据传输之前传输了多少字节。如果数据是动态生成的，你必须首先在发送之前缓冲所有的数据，以计算字节数。

通过使用请求结束标记，你不必知道你发送了多少字节。您只需要在数据末尾发送一个请求结束标记。但是，您必须确保发送的数据不包含任何可能被误认为请求结束标记的数据。有一种方法可以做到:

假设请求结束标志是字节值 255。当然，数据也可以包含值 255。因此，对于数据中包含值 255 的每个字节，都要添加一个额外的字节，也是值 255。请求结束标志从字节值 255 改变为 255，后跟值 0。以下是总结的编码:

```
255 in data    --> 255, 255
end-of-request --> 255, 0

```

序列 255，0 不能出现在数据中，因为您要将所有 255 更改为 255，255。并且，一个 255，255，0 不会被误认为是一个 255，0。前 255 将一起解释，后 0 单独解释。

## 穿透防火墙

大多数防火墙会阻止除 HTTP 协议之外的所有其他流量。因此，像 XML-RPC、SOAP 和 REST 一样，将你的协议放在 HTTP 之上是一个好主意。

为了将你的协议放在 HTTP 之上，你在 HTTP 请求和响应中在客户机和服务器之间来回发送你的数据。请记住，HTTP 请求和响应可以不仅仅包含文本或 HTML。你也可以在那里发送二进制数据。

将您的请求放在 HTTP 协议上唯一有点奇怪的是，HTTP 请求**必须**包含一个“Host”头字段。如果你在 HTTP 之上设计一个 P2P 协议，你的对等体很可能不会运行多个“主机”。在这种情况下，这个必需的头字段是一个不必要的开销(但是很小)。