# RSync -校验和

> 原文:[https://jenkov.com/tutorials/rsync/checksums.html](https://jenkov.com/tutorials/rsync/checksums.html)

在前面的文章中，我解释过 RSync 使用校验和来检测文件的一个版本中的块是否等于另一个版本中的块。

> 校验和是一种基于较大数据块计算较小值(以字节为单位)的算法。比如哈希值。

由于校验和通常比数据本身小得多，比如说对 1024 字节的数据块计算的 16 字节校验和，当然多个不同的数据块会产生相同的校验和。校验和所能做的最好的事情是，如果两个块的校验和相等，那么这两个块很可能相等。

事实上，从数据块中计算校验和遵循以下两条规则:

*   如果校验和不相等，您可以 100%确定这两个数据块不相等。使用相同的校验和算法，相等的数据块将产生相同的校验和。
*   如果校验和相等，块也可能相等，但这不是 100%的保证。

与数据块相比，校验和越大(字节越多)，如果它们的校验和匹配，则两个数据块相等的可能性就越大。例如，1024 字节校验和上的 1 字节校验和将导致许多数据块产生相同的校验和。16 字节校验和将导致产生相同校验和的数据块少得多。

## 校验和比较真的足够好吗？

校验和算法通常被设计成对数据块进行小的改变，而对校验和进行大的改变。而且，通常你要么对一个文件做较小的修改，要么向其中添加全新的数据。因此，比较校验和可以给出两个数据块相等的概率，但不能保证 100%。

实际上，您的文件通常不会完全随机地发生变化。首先，你经常对它们做一些小的改动，大多数校验和算法都能捕捉到。第二，不是所有的文件类型都可以接受数据块的所有可能的变化。文件格式通常会将某种结构强加到文件中，这就限制了一块数据可能出现的突变数量。

然而，到了最后，你得到的只是两个数据块相等的可能性很高，但不是 100%的保证。与发送整个文件相比，这是更快的文件同步的代价。

### 补偿校验和风险

大多数情况下，您会使用 RSync 来备份文件。当然，您不希望您的文件被错误地备份，因为不同块的校验和是相同的。但是您仍然需要更快的备份。这里有一个补偿的方法。

第一次备份文件时，通过网络复制整个文件。实际上，如果使用 RSync 比较一个非空文件和一个空文件(还没有预先存在的远程副本),文件将被正确地复制。

通常你会定期备份文件。例如，您每天备份文件。然后，您可以在每个星期天创建一个完整副本，并在本周的其余时间进行 RSync 备份。这确保了至少每周都有 100%的完整、正确的备份保证。在这一周的剩余时间里，你有很高的可能性进行正确的备份。当然，您必须将周日的文件与一周中的其他备份分开，以确保不会覆盖您的完整、正确的副本。

## 选择校验和算法

如果块的校验和相等，要有块相等的合理可能性，请选择稍大的校验和算法。我说的“大”是指产生更大字节值的。在我的 RSync 实现中，我选择了 16 字节哈希算法作为校验和算法。

16 字节哈希算法对文件中每个可能的数据块进行计算的速度很慢(请记住逐字节迭代)。因此，16 字节哈希算法与更小、更快的滚动校验和算法相结合。

RSync 使用快速滚动校验和算法快速剔除校验和不匹配的情况。如前所述，如果两个块的校验和不相等，则这两个块也不相等。与 16 字节哈希算法相比，更快的校验和算法当然会导致更频繁的校验和匹配。因此，当发现滚动校验和匹配时，也会计算该块的 16 位哈希值。如果滚动校验和与 16 字节哈希值匹配，则认为匹配。

### 滚动校验和算法

RSync 中使用的滚动校验和算法由两个值组成。一个 A 值和一个 B 值。在最初的 RSync 算法中，A 和 B 是 16 位值。在我自己的实现中，它们每个都是 32 位值。

更快滚动校验和算法的有趣之处在于，当计算校验和的块滚动时，只需减去刚移出块的字节值，再加上刚移入块的值，就可以更新校验和。这使得计算滚动数据块的校验和变得非常快。

这些值最初是如何在数据块上计算的:

```
data = array of data where block of data exists in.
i    = index into block. Goes from 0 to blockSize-1;

A = data[0] + data[1] + ... data[i];
B = blockSize * data[0] + (blockSize-1) * data[1]
    + ... +
    (blockSize - i) * data[i] ... + 1 * data[blockSize-1];

```

有趣的是，计算 B 的另一种方法是，每当 A 更新时，就给它加上 A，如下所示:

```
A += data[i];
B += A;

```

为什么会这样呢？data[]中的字节一次加一个。第一次向添加一个字节时，A 等于该字节的值。这也等于 1 * data[I]；

当你把下一个字节加到 A 上，再把 A 加到 B 上时，第一个字节已经加了两次到 B 上，第二个字节加了一次。这等于`2 * data[0] + 1 * data[1]`。

当你继续这样做，直到块大小，第一个字节将被添加到 B `blockSize`次，第二个字节被添加`blockSize - 1`次，等等。它等于 b 的第一个公式。

当更新 A 和 B 时，当数据块向下 1 字节时，你这样更新 A 和 B:

```
start = start index of new block.
end   = end index of new block.  

A -= data[start-1];   //remove old, first byte.
A += data[end];

B -= blockSize * data[start-1];
B += A;

```

### 散列算法

RSync 最初使用 MD4 作为校验和，但根据 RSync 上的[Wikipedia 页面，后来已经更改为使用 MD5。Java 有一个内置的实现，可以用于这两种算法。](http://http://en.wikipedia.org/wiki/Rsync)