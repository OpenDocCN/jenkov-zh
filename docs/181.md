# RION 设计目标

> 原文：<https://jenkov.com/tutorials/rion/rion-design-goals.html>

RION 是一种二进制数据格式，它非常灵活，可以对多种数据进行编码。在设计 RION 时，我们希望 RION:

*   快速的
*   小型的，紧凑的
*   表现力丰富-多才多艺
*   自我描述
*   键入的空值
*   部分可分析性
*   任意层次导航
*   循环对象图
*   适合作为网络协议消息格式
*   独立于网络协议
*   轻便的
*   易于为分配内存
*   易于服务器处理
*   易于处理小型设备

## 快速的

性能是 RION 的一个重要设计目标。无论如何，当我们重新发明一种数据格式时，为什么不试着让它尽可能快呢？我们已经用 RION 试过了，我们最初的测量看起来很有希望。

我们实现了一个与 RION 一起工作的工具包，名为 RION Ops for Java。这个工具包是开源的。我们当前的性能测量基于 RION Ops 的性能。为了比较 RION 和 JSON 的性能，我们使用了 Jackson JSON 解析器，它是目前最快的 JSON 解析器之一。

作为二进制格式，RION 的读写速度自然比文本格式快。从二进制形式读写布尔值、整数、浮点和二进制数据比从文本形式读写要快。我们已经看到，与使用 Jackson 从 JSON 读取相同的 Java 对象或将相同的 Java 对象写入 JSON 相比，性能提高了 1000% (x 10)。不过平均来说，预计速度会提高 50%到 200%。

速度的提高取决于被序列化的数据的类型和大小。到目前为止，对于不能很好地序列化为文本的小对象和类型，如布尔和浮点变量，速度差异似乎最大。Jackson 在序列化整数方面非常快，所以速度平均提高了 0 到 50%。

例外情况是在读写文本时——在这种情况下，RION 的性能应该与 JSON 和 XML 之类的文本格式差不多。但是即使是文本，RION Ops 也有一些内置的类，可以使读写文本更快。这些技术也可以用在 JSON 解析器中——但是目前看来还没有。

### 读取速度与写入速度

在少数情况下，我们不得不在读取速度/灵活性和写入速度/灵活性之间进行权衡。在这些情况下，我们通常会考虑读写速度和灵活性的得失。

在一个动作的速度增益明显大于另一个动作的速度损失的情况下，我们决定支持速度增益。

在一方获得的速度与另一方损失的速度大致相等的情况下，我们决定提高读取速度。我们这样做有以下两个原因:

首先，我们假设 RION 消息的平均读取次数与写入次数相同或更多。例如，您可以将表格数据(类似于 CSV 文件)写入 RION 文件，然后必须在以后多次读取这些文件。数据文件和日志文件都是这种情况(至少有时是这样)。

在发送者和最终接收者之间路由信息的系统也是如此。RION 消息可以作为单个不透明的字节块读取，因此对于不需要处理消息中的数据的中间节点来说，转发速度非常快。

第二，RION 的写速度已经高于 RION 的读速度，所以通过在 50-50 的情况下决定读速度，两种格式之间的速度差异就可以稍微平衡了。

## 小型的，紧凑的

除了读写速度快之外，RION 还被设计成紧凑的序列化形式。紧凑的数据格式可以在网络上传输得更快。

您可能会声称紧凑性并不重要，因为您可以对通过网络发送的数据进行 ZIP 压缩。像 JSON 和 XML 这样的文本数据格式压缩得非常好，所以如果 JSON、XML 和 RION 都是 ZIP 压缩的，那么传输的数据大小的实际差异会小得多。

但是，如果您通过 TLS 连接(加密连接)发送压缩数据，您的数据通信很可能会受到破坏和犯罪攻击。因此，目前(2015 年 11 月)建议在通过 TLS 连接发送数据时关闭压缩。然后，突然之间，数据的紧凑性又变得重要起来。

TLS 上的压缩问题可能会在将来得到解决。但是即使这样，紧凑的数据格式仍然是一种优势，尽管是一种较小的格式，只要这种紧凑性不会对性能产生太大影响。解压缩少量数据仍然比解压缩大量数据更快，而且对于客户端和服务器来说也更容易处理(需要的内存更少)。

平均来说，RION 对象比相应的 JSON 消息小 10-20%。具体多少取决于发送的是什么数据。例如，较大的整数比较小的整数需要更多的字符来编码为文本。里翁也是如此。

### 紧凑表格数据

通过网络发送表格数据，例如对象列表，是一种常见的用例。将对象数组序列化为 JSON 时，每个对象都被序列化为属性名+属性值对。这意味着每个对象的属性名称都是重复的。

为了在序列化相同类型对象的数组时避免属性名的重复，RION 有一个特殊的表字段类型。RION 表数据类型只包含一次属性名。在属性名称之后，数组中所有对象的属性值都包含在与属性名称相同的序列中。因此，RION 表在结构上类似于只有一个标题行的 CSV 文件。

此外，没有每行指示器开销。每一行的字段都嵌套在一个很长的字段序列中。表中列字段的数量指定每行有多少列。

RION 表比 JSON 对象数组紧凑得多。我们已经看到数据大小不到 JSON 的 1/3。具体节省多少取决于属性名称的长度。

RION 表的编写速度更快，因为不必多次编写属性名。RION 表的读取速度也更快，因为可以使用索引而不是属性名将属性值映射到 Java 对象中的属性。使用属性值的索引节省了对属性名称的读取+对每个属性的散列表查找。RION 表更紧凑，在网络上传输也更快。

### 紧凑的树形结构

您可以在表字段中嵌套任何 RION 字段，包括其他表字段。因此，您可以使用嵌套的表字段来建模一个紧凑的树结构，其中“子”对象的列表只有在每个列表中重复一次的列名。

### 紧凑对象结构

如果您需要单个 RION 对象字段(一组键+值对)的最大紧凑性，您可以省略键，只包含值。这相当于序列化一个没有属性名的 JSON 对象，只有属性值本身。但是，您需要知道什么属性值对应于哪个属性名。您可以通过 RION 对象字段中属性值的索引来实现这一点。例如，属性值 0 是 ID，值 1 是名，值 2 是姓，值 3 是电子邮件等。

## 表现力丰富-多才多艺

RION 从一开始就被设计得极具表现力。用户越少需要求助于其他数据格式越好。如果我们都可以在 RION 中交换数据，我们就可以使用相同的数据解析器和生成器。RION 能够表达你能用 CSV、JSON 和 XML 表达的一切。这意味着您实际上可以将 CSV、JSON 或 XML 文件转换为 RION 文件，而不会丢失信息。

是的，这也是他们对 XML 的评价，但是对 XML 来说，结果并不成功。文本数据格式天生不适合发送二进制数据，如数字和文件。我们相信 RION 改变了这一点，所以现在轮到我们对 RION 傲慢自大了，声称它是一种通用数据格式。

RION 旨在能够对这些常用的数据类型和数据结构进行建模:

*   Raw bytes
*   布尔字段
*   整数字段
*   浮点字段
*   UTF-8 个油田
*   UTC 日期时间字段
*   二进制文件
*   字段流(无界)
*   字段数组(有界)
*   表格(如 CSV 文件)
*   映射(键，值对)
*   具有属性的对象(键、值对)
*   对象内有对象的对象图等。(比如 JSON)
*   混合的对象(元素)、文本和二进制字段(如 XML)

RION 有几个原始的单值字段，用于编码常见的简单数据类型，如整数、浮点、UTF-8 字符串等。

RION 还包含三种复合字段类型:数组、表和对象。这些字段类型中可以嵌套其他 RION 字段。因此，你可以通过嵌套创建复合数据结构，例如数组中的对象，表中的对象，表中的表等等。

当然，内置的 RION 数据类型并不适合所有类型的数据。如果您需要发送 RION 不支持的内容(如 MPEG、JPEG 等)。)，你可以把它作为原始字节发送(RION 支持)。这从一开始就是一个优先事项——当传输 RION 没有明确设计编码的数据时，用户可以默认使用不透明的字节序列。也可以定义自己的对象类型。稍后会详细介绍。

## 自我描述

我们希望 RION 文件/对象是自描述的。应该可以在没有模式的情况下解析 RION 文件/对象，就像处理 JSON 文件一样。这在 RION 身上是可能的。您可能看不到正在传输的数据的确切语义，但是您可以在不使用模式的情况下看到 RION 对象包含哪些字段和数据类型。

自描述数据格式在开发过程中更容易使用，因为您不需要知道数据的模式就可以研究它。

## 键入的空值

在一些数据格式中，值`null`是它自己的“类型”,这意味着空值没有附加的显式类型信息，除非它是空的。换句话说，你不能看到它是否是一个空整数，空字符串，空浮点，空字节数组，空日期时间等等。你所能看到的是，这个值是`null`。

为了让 RION 尽可能的自我描述，它应该最好输入空值。在当前的编码中，每个字段类型都可以取值 null，而不会丢失有关其类型的信息。

## 部分可分析性

在您的特定用例中，服务经常会返回比您实际需要的更多的数据。如果该服务是由其他人而不是您自己的组织提供的公共服务，则尤其如此。

为了能够在这种情况下提升性能，我们希望 RION 能够*部分解析*。所谓部分可解析性，我的意思是你不需要解析一个 RION 数据结构的全部来找到你需要的属性。

RION 使用 TLV 编码的事实使得跳过不需要的字段的所有字节变得很容易。如果一个字段值有 15 个字节长，你可以在该字段的第一个字节中看到(前导字节+长度字节)。如果不需要这个字段，可以跳过这 15 个值字节，直接检查下一个 RION 字段。这对于 JSON 编码的数据结构是不可能的。在 JSON 中，您必须检查 15 个值字节中的每一个，以查看字段值的结束位置。

如果您跳过的 RION 字段是复合 RION 字段，这种性能优势会更大。您可以跳过复合字段的所有嵌套字段，而不必检查嵌套在复合 RION 字段中的每个字段。这是可能的，因为复合字段还在复合字段的开头指定所有嵌套字段的完整长度(以字节为单位)。

## 任意层次导航

部分可解析性实现了我们为 RION 设定的另一个目标——即*任意层次导航*。通过任意的层次导航，我们的意思是应该能够快速和容易地移入和移出复合数据结构，例如树结构。如果在检查了父字段的第一个嵌套字段后，您意识到不需要该父字段，应该可以快速轻松地从父字段的主体中移出，并移到与该父字段处于同一级别的下一个字段，即复合字段。

RION 一致的 TLV 编码(也适用于复合场)意味着这相当容易实现。

## 循环对象图

许多流行的数据格式只能对非循环对象图进行编码，这意味着编码数据中的对象只能引用后来在编码数据中找到的对象，而不能向后引用以前在编码数据中找到的对象。

我们希望 RION 能够编码循环对象图。我们设想通过向 RION 添加一个引用字段来实现这一点，这样在编码 RION 块中后来找到的对象就可以“回”引用在编码 RION 数据中早先找到的对象。

引用还没有正式指定，但是我们有一些可行的想法来实现一个既紧凑又易于使用的引用字段。

## 适合作为网络协议消息格式

正如在别处提到的，RION 最初是作为分布式系统中数据交换的数据格式而设计的。因此，RION 是我们的应用层网络协议 IAP 中使用的消息格式。因此 RION 自然适合这个任务。RION 是根据消息格式、客户机、服务器、路由器等的需求而设计的。牢记在心。

## 独立于网络协议

虽然 RION 是作为 IAP 的一部分设计的，但 RION 是一种独立于网络协议的数据格式。因此，您可以在 IAP 之外使用 RION 作为 JSON、XML、YAML 等的替代数据格式。由于 RION 相当紧凑和快速，在 HTTP 上使用 RION 可能是希望从 HTTP/JSON、SOAP/XML 等转换到 IAP 的组织的第一步。

您甚至可以使用 RION 作为文件格式。正如您将在后面看到的，RION 是 CSV 文件的一个很好的替代品。您还可以使用 RION 作为日志文件格式。浏览文件中的 RION 记录会非常快。

## 轻便的

由于 RION 将在 IAP(一种面向消息的网络协议)中使用，所以 RION 消息易于为中间节点路由自然是很重要的。由于 RION 消息是自描述的，所以很容易看出 RION 消息的开始和结束时间。部分读取一个 RION 消息，或者将其包装在另一个 RION 消息中进行隧道传输也很容易。

我们所说的“路由”是指应用层的路由，而不是 IP 层的。常规 IP 路由不需要检查 IP 帧内的数据。但是，如果您正在实现中继服务器、P2P 网络、洋葱路由或类似的技术，您的自定义路由逻辑可能需要检查消息，以确定将它路由到哪里。

需要模式来解释的消息格式(如 Protobuf 或 Avro)在应用层不容易路由。中间路由器必须知道模式，以便能够解码消息并路由它。这并不理想。相反，您可以将这种数据格式包装在像 RION 这样的自描述数据格式中，但是为什么现在只将所有数据保存在 RION 中呢？为什么有处理多种数据格式的麻烦？

## 易于为分配内存

RION 应该很容易分配内存。我的意思是，从一个入站 RION 消息的开始就应该很容易看到整个消息将占用多少内存，这样就可以一次分配完。

RION 一致的 TLV 编码——也适用于复合字段——使得从 RION 编码消息的前几个字节中很容易看出整个消息占用了多少字节。因此，您可以为它分配精确的所需字节数——或者为它找到一个适当大小的可重用字节缓冲区(不要太小，也不要太大)。

## 易于服务器处理

对于接收大量消息的服务器来说，RION 应该很容易处理。“处理”指的是服务器设计的几个不同方面。

首先，它应该很容易知道什么时候一个消息开始，什么时候一个完整的消息已经收到，而不必看整个消息。使用 RION 消息很容易做到这一点。

其次，应该很容易为 RION 消息分配正确的内存量。此外，RION 消息应该完全包含在一个连续的内存区域中。这使得为消息分配和释放内存更快/更容易，并且处理消息也更快(整个消息可能适合服务器的 L1、L2 或 L3 缓存)。我之前提到过，分配内存很容易。这是原因之一。

第三，应该可以只阅读部分信息，而不必阅读整个信息。部分读取消息可以更容易地实现多步消息处理管道，其中每一步都解析越来越多的消息，并将其传递给服务器中正确的子系统。对于 RION 消息，这也相当容易做到。这也类似于我之前提到的部分可解析性和任意层次导航。

## 易于处理小型设备

面向小型设备的网络协议，如物联网(IoT ),应该具有易于小型设备处理的数据和消息格式。不仅仅是大型服务器。小数据大小、消息大小、快速读写时间以及容易的存储器管理是小设备的关键。