# Java 枚举

> 原文：<https://jenkov.com/tutorials/java/enums.html>

Java 枚举是一种特殊的 Java 类型，用于定义常量集合。更准确地说，Java 枚举类型是一种特殊的 Java 类。枚举可以包含常量、方法等。Java 5 中增加了 Java 枚举。

这个 Java 枚举教程解释了如何创建和使用 Java 枚举。如果你喜欢视频，我这里有这个教程的视频版本:

<iframe width="560" height="315" src="https://www.youtube.com/embed/1612Ngij7_c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""><h2>枚举示例</h2> <p>下面是一个简单的 Java 枚举示例:</p> <pre class="codeBox"> public enum Level { HIGH, MEDIUM, LOW } </pre> <p>注意用于代替<code>class</code>或<code>interface</code>的关键词<code>enum</code>。Java <code>enum</code>关键字通知 Java 编译器这个类型定义是一个枚举。</p> <p>您可以像这样引用上面枚举中的常量:</p> <pre class="codeBox"> Level level = Level.HIGH; </pre> <p>注意<code>level</code>变量是如何属于类型<code>Level</code>的，这是上面例子中定义的 Java 枚举类型。<code>level</code>变量可以将<code>Level</code>个枚举常量之一作为值(<code>HIGH</code>、<code>MEDIUM</code>或<code>LOW</code>)。在这种情况下，<code>level</code>被设置为<code>HIGH</code>。</p> <h2>if 语句中的枚举</h2> <p>因为 Java 枚举是常量，所以您经常需要将指向枚举常量的变量与枚举类型中可能的常量进行比较。下面是一个在<code>if</code>-语句中使用 Java 枚举的例子:</p> <pre class="codeBox"> Level level = ... //assign some Level constant to it if( level == Level.HIGH) { } else if( level == Level.MEDIUM) { } else if( level == Level.LOW) { } </pre> <p>这段代码将<code>level</code>变量与<code>Level</code>枚举中每个可能的枚举常量进行比较。</p> <p>如果某个枚举值比其他值出现得更频繁，那么在第一个<code>if</code>-语句中检查该值将会获得更好的性能，因为平均来说执行的比较更少。不过，这并不是一个很大的区别，除非经常进行比较。</p> <h2>switch 语句中的枚举</h2> <p>如果您的 Java 枚举类型包含许多常量，并且您需要检查变量的值，如前一节所示，那么使用 Java <code>switch</code>语句可能是个好主意。</p> <p>可以在 switch 语句中使用枚举，如下所示:</p> <pre class="codeBox"> Level level = ... //assign some Level constant to it switch (level) { case HIGH : ...; break; case MEDIUM : ...; break; case LOW : ...; break; } </pre> <p>如果<code>level</code>变量与给定的级别常量值匹配，则用要执行的代码替换<code>...</code>。代码可以是简单的 Java 操作、方法调用等。</p> <h2>枚举迭代</h2> <p>通过调用 Java enum 类型的静态<code>values()</code>方法，可以获得该类型所有可能值的数组。所有枚举类型都由 Java 编译器自动获得一个静态的<code>values()</code>方法。以下是迭代枚举的所有值的示例:</p> <pre class="codeBox"> for (Level level : Level.values()) { System.out.println(level); } </pre> <p>运行这段 Java 代码将打印出所有的枚举值。以下是输出:</p> <pre class="codeBox"> HIGH MEDIUM LOW </pre> <p>注意常量本身的名称是如何打印出来的。这是 Java 枚举不同于<code>static final</code>常量的一个方面。</p> <h2>Enum toString()</h2> <p>一个枚举类在编译时会自动获取该类中的一个<code>toString()</code>方法。<code>toString()</code>方法返回给定枚举实例名称的字符串值。这里有一个例子:</p> <pre class="codeBox"> String levelText = Level.HIGH.toString(); </pre> <p>执行上述语句后，<code>levelText</code>变量的值将是文本<code>HIGH</code>。</p> <h2>枚举打印</h2> <p>如果打印一个枚举，如下所示:</p> <pre class="codeBox"> System.out.println(Level.HIGH); </pre> <p>然后会在后台调用<code>toString()</code>方法，所以输出的值是枚举实例的文本名称。换句话说，在上面的例子中，文本<code>HIGH</code>将被打印出来。</p> <h2>的枚举值()</h2> <p>enum 类在编译时会自动获取类中的静态<code>valueOf()</code>方法。<code>valueOf()</code>方法可用于获取给定字符串值的枚举类的实例。这里有一个例子:</p> <pre class="codeBox"> Level level = Level.valueOf("HIGH"); </pre> <p>执行完这一行后,<code>level</code>变量将指向<code>Level.HIGH</code>。</p> <h2>枚举字段</h2> <p>您可以向 Java 枚举添加字段。因此，每个常量枚举值都会得到这些字段。定义常数时，必须将字段值提供给枚举的构造函数。这里有一个例子:</p> <pre class="codeBox"> public enum Level { HIGH (3), //calls constructor with value 3 MEDIUM(2), //calls constructor with value 2 LOW (1) //calls constructor with value 1 ; // semicolon needed when fields / methods follow private final int levelCode; private Level(int levelCode) { this.levelCode = levelCode; } } </pre> <p>注意上面例子中的 Java enum 有一个带<code>int</code>的构造函数。枚举构造器设置<code>int</code>字段。当常量枚举值被定义时，一个<code>int</code>值被传递给枚举构造函数。</p> <p><code>enum</code>构造函数必须是<code>private</code>。你不能为一个 Java <code>enum</code>使用<code>public</code>或<code>protected</code>构造函数。如果你没有指定一个访问修饰符<code>enum</code>构造函数，它将被隐式地<code>private</code>。</p> <h2>枚举方法</h2> <p>您也可以向 Java 枚举添加方法。这里有一个例子:</p> <pre class="codeBox"> public enum Level { HIGH (3), //calls constructor with value 3 MEDIUM(2), //calls constructor with value 2 LOW (1) //calls constructor with value 1 ; // semicolon needed when fields / methods follow private final int levelCode; Level(int levelCode) { this.levelCode = levelCode; } <b> public int getLevelCode() { return this.levelCode; } </b> } </pre> <p>通过引用一个常量值来调用 Java enum 方法。以下是 Java enum 方法调用示例:</p> <pre class="codeBox"> Level level = Level.HIGH; System.out.println(level.getLevelCode()); </pre> <p>这段代码将打印出值<code>3</code>，它是枚举常量<code>HIGH</code>的<code>levelCode</code>字段的值。</p> <p>您并不局限于简单的 getter 和 setter 方法。还可以创建基于 enum 常量的字段值进行计算的方法。如果您的字段没有声明<code>final</code>，您甚至可以修改字段的值(尽管这可能不是一个好主意，考虑到枚举应该是常量)。</p> <h2>枚举抽象方法</h2> <p>Java 枚举类也可能有抽象方法。如果一个枚举类有一个抽象方法，那么该枚举类的每个实例都必须实现它。下面是一个 Java enum 抽象方法示例:</p> <pre class="codeBox"> public enum Level { HIGH{ @Override public String asLowerCase() { return HIGH.toString().toLowerCase(); } }, MEDIUM{ @Override public String asLowerCase() { return MEDIUM.toString().toLowerCase(); } }, LOW{ @Override public String asLowerCase() { return LOW.toString().toLowerCase(); } }; public abstract String asLowerCase(); } </pre> <p>注意 enum 类底部的抽象方法声明。还要注意每个枚举实例(每个常量)是如何定义这个抽象方法的自己的实现的。当您需要为 Java 枚举的每个实例使用不同的方法实现时，使用抽象方法非常有用。</p> <h2>枚举实现接口</h2> <p>一个 Java <code>Enum</code>可以实现一个<a href="interfaces.html"> Java 接口</a>，如果你觉得在你的情况下有意义的话。下面是一个 Java <code>Enum</code>实现接口的例子:</p> <pre class="codeBox"> public enum EnumImplementingInterface implements MyInterface { FIRST("First Value"), SECOND("Second Value"); private String description = null; private EnumImplementingInterface(String desc){ this.description = desc; } @Override public String getDescription() { return this.description; } } </pre> <p>就是来自接口<code>MyInterface</code>的方法<code>getDescription()</code>。</p> <p>用一个<code>Enum</code>实现一个接口可以用来实现一组不同的<code>Comparator</code>常量，这些常量可以用来对对象集合进行排序。Java 中对象的排序在<a href="/java-collections/sorting.html"> Java 集合排序教程</a>中有更详细的解释。</p> <h2>enumset 集</h2> <p>Java 包含一个名为<code>EnumSet</code>的特殊的<a href="/java-collections/set.html"> Java Set </a>实现，它可以比标准的 Java Set 实现更有效地保存枚举。下面是如何创建一个<code>EnumSet</code>的实例:</p> <pre class="codeBox"> EnumSet&lt;Level&gt; enumSet = EnumSet.of(Level.HIGH, Level.MEDIUM); </pre> <p>一旦创建，您就可以像使用其他集合一样使用<code>EnumSet</code>。</p> <h2>枚举数</h2> <p>Java 还包含一个特殊的<a href="/java-collection/map.html"> Java Map </a>实现，它可以使用 Java enum 实例作为键。下面是一个 Java <code>EnumMap</code>的例子:</p> <pre class="codeBox"> EnumMap&lt;Level, String&gt; enumMap = new EnumMap&lt;Level, String&gt;(Level.class); enumMap.put(Level.HIGH , "High level"); enumMap.put(Level.MEDIUM, "Medium level"); enumMap.put(Level.LOW , "Low level"); String levelValue = enumMap.get(Level.HIGH); </pre> <h2>枚举杂项详细信息</h2> <p>Java 枚举隐式扩展了<code>java.lang.Enum</code>类，所以你的枚举类型不能扩展另一个类。</p> <p>如果 Java enum 包含字段和方法，那么字段和方法的定义必须总是在 enum 中常量列表的后面。此外，枚举常量列表必须以分号结束；</p> </body> </html></iframe>