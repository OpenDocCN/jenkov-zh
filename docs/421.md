# Java 流 API

> 原文：<https://jenkov.com/tutorials/java-functional-programming/streams.html>

Java *Stream* API 提供了处理对象集合的函数方法。Java 8 中添加了 Java Stream API 和其他几个函数式编程特性。这个 Java 流教程将解释这些函数流是如何工作的，以及你如何使用它们。

Java Stream API 与 [Java IO](/java-io/index.html) 的 [Java InputStream](/java-io/inputstream.html) 和 Java output Stream 无关。 `InputStream`和`OutputStream`与字节流相关。Java 流 API 用于处理对象流，而不是字节流。

## Java Stream API 教程-视频版

我这里有这个教程的视频版本:

<iframe width="560" height="315" src="https://www.youtube.com/embed/bcrl-GL0vV4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">&#13; &#13; &#13; &#13; &#13; &#13; <h2>Java 流定义</h2>&#13; &#13; <p>Java <em>流</em>是一个能够对其元素进行<em>内部迭代</em>的组件，这意味着它可以自己&#13;迭代其元素。相反，当你使用&#13; <a href="/java-collections/index.html"> Java 集合</a>迭代特性&#13;(例如<a href="/java-collections/iterator.html"> Java 迭代器</a>或 Java for-each 循环使用&#13;与<a href="/java-collections/iterable.html"> Java Iterable </a>)时，你必须自己实现元素的迭代&#13;。&#13;</p>&#13; &#13; &#13; &#13; &#13; &#13; <h2>流处理</h2>&#13; &#13; <p>您可以将<em>监听器</em>附加到<code>Stream</code>上。当<code>Stream</code> &#13;在内部迭代元素时，调用这些监听器。针对流中的每个元素调用一次侦听器。这样，每个&#13;监听器都可以处理流中的每个元素。这被称为<em>流处理</em>。&#13;</p>&#13; &#13; <p>流的侦听器形成一个链。链中的第一个侦听器可以处理流中的元素，然后返回一个新元素供链中的下一个侦听器处理。侦听器可以返回相同的元素或新的，这取决于侦听器(处理器)的用途。</p>&#13; &#13; &#13; &#13; &#13; <h2>获得一个流</h2>&#13; &#13; <p>有很多方法可以获得 Java <em>流</em>。获得<code>Stream</code> &#13;最常见的方法之一是从<a href="/java-collections/index.html"> Java 集合</a>中获得。下面是一个从<a href="/java-collections/list.html"> Java 列表</a> : &#13;中获取&#13; <code>Stream</code>的例子</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; items = new ArrayList&lt;String&gt;();&#13; &#13; items.add("one");&#13; items.add("two");&#13; items.add("three");&#13; &#13; Stream&lt;String&gt; stream = items.stream(); &#13; </pre>&#13; &#13; <p>这个例子首先创建一个 Java <code>List</code>，然后向它添加三个<a href="/java/strings.html"> Java 字符串</a> &#13;。最后，该示例调用<code>stream()</code>方法来获得一个<code>Stream</code>实例。&#13;</p>&#13; &#13; &#13; &#13; &#13; &#13; <h2>终端和非终端操作</h2>&#13; &#13; <p><code>Stream</code>界面有<em>终端</em>和<em>非终端</em>操作的选择。&#13;一个<em>非终结流操作</em>是一个向流中添加监听器而不做任何其他事情的操作。&#13;一个<em>终端流操作</em>是启动元素内部迭代，调用&#13;所有监听器，并返回结果的操作。&#13;</p>&#13; &#13; <p>下面是一个 Java 流示例，其中包含非终端和终端操作:</p>&#13; &#13; <pre class="codeBox">&#13; import java.util.ArrayList;&#13; import java.util.List;&#13; import java.util.stream.Stream;&#13; &#13; public class StreamExamples {&#13; &#13; public static void main(String[] args) {&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("ONE");&#13; stringList.add("TWO");&#13; stringList.add("THREE");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; long count = stream&#13; .map((value) -&gt; { return value.toLowerCase(); })&#13; .count();&#13; &#13; System.out.println("count = " + count);&#13; &#13; }&#13; }&#13; </pre>&#13; &#13; <p>对<code>Stream</code>接口的<code>map()</code>方法的调用是非终结操作。&#13;它只是在流上设置一个 lambda 表达式，将每个元素转换成小写。<code>map()</code> &#13;方法将在后面详细介绍。&#13;</p>&#13; &#13; <p>对<code>count()</code>方法的调用是一个终端操作。这个调用在内部开始迭代，&#13;,这将导致每个元素被转换成小写，然后被计数。&#13;</p>&#13; &#13; <p>将元素转换为小写实际上不会影响元素的数量。转换部分只是作为一个非终结操作的例子。</p>&#13; &#13; &#13; &#13; &#13; &#13; <h2>非终点操作</h2>&#13; &#13; <p>Java 流 API 的非终结流操作是转换或过滤流中元素的操作。当您向流中添加一个非终结操作时，您会得到一个新的流作为结果。新流表示由应用了非终结符操作的原始流产生的元素流。下面是一个添加到流中的非终结符操作的例子，它产生了一个新的流:</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("ONE");&#13; stringList.add("TWO");&#13; stringList.add("THREE");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; Stream&lt;String&gt; stringStream =&#13; stream.map((value) -&gt; { return value.toLowerCase(); });&#13; </pre>&#13; &#13; <p>注意对<code>stream</code>的调用<code>map()</code>。这个调用实际上返回了一个新的&#13; <code>Stream</code>实例，代表应用了映射操作&#13;的原始字符串流。&#13;</p>&#13; &#13; <p>您只能向给定的<code>Stream</code>实例添加一个操作。如果您需要将多个&#13;操作串联起来，您需要将第二个操作应用于第一个操作产生的<code>Stream</code>操作&#13;。下面是它的样子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; Stream&lt;String&gt; stringStream1 =&#13; stream.map((value) -&gt; { return value.toLowerCase(); });&#13; &#13; Stream&lt;½String&gt; stringStream2 =&#13; stringStream1.map((value) -&gt; { return value.toUpperCase(); });&#13; </pre>&#13; &#13; <p>注意第二个对<code>Stream</code> <code>map()</code>的调用是如何在第一个<code>map()</code>调用返回的<code>Stream</code> &#13;上被调用的。&#13;</p>&#13; &#13; <p>在 Java <code>Stream</code>上，将调用链接到非终结操作是很常见的。下面是一个在 Java 流上链接非终结操作调用的&#13;示例:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; Stream&lt;String&gt; stream1 = stream&#13; .map((value) -&gt; { return value.toLowerCase(); })&#13; .map((value) -&gt; { return value.toUpperCase(); })&#13; .map((value) -&gt; { return value.substring(0,3); });&#13; </pre>&#13; &#13; <p>许多非终结流操作可以将一个<a href="/java/lambda-expressions.html"> Java Lambda 表达式</a> &#13;作为参数。这个 lambda 表达式实现了一个适合给定非终结操作的<a href="/java-functional-programming/functional-interfaces.html"> Java 函数接口</a> &#13;。例如，<code>Function</code>或<code>Predicate</code> &#13;接口。非终结操作方法参数的参数通常是一个函数接口——这就是为什么它也可以由 Java lambda 表达式实现的原因。&#13;</p>&#13; &#13; &#13; &#13; &#13; <h3>过滤器()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>filter()</code>可以用来从 Java <code>Stream</code>中过滤出元素。&#13;<code>filter</code>方法采用了一个<code>Predicate</code>，它被流中的每个元素调用。&#13;如果元素要包含在结果<code>Stream</code>中，<code>Predicate</code>应该返回&#13; <code>true</code>。如果元素不应该被包含，那么<code>Predicate</code>应该返回<code>false</code>。&#13;</p>&#13; &#13; <p>下面是一个调用 Java <code>Stream</code> <code>filter()</code>方法的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; Stream&lt;String&gt; longStringsStream = stream.filter((value) -&gt; {&#13; return value.length() &gt;= 3;&#13; });&#13; </pre>&#13; &#13; &#13; &#13; &#13; &#13; <h3>地图()</h3>&#13; <p>Java <code>Stream</code> <code>map()</code>方法将一个元素转换(映射)为另一个对象。例如，&#13;如果你有一个字符串列表，它可以将每个字符串转换成小写，大写，或者转换成原始&#13;字符串的子串，或者其他完全不同的东西。下面是一个 Java<code>Stream</code>T3 的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; list = new ArrayList&lt;String&gt;();&#13; Stream&lt;String&gt; stream = list.stream();&#13; &#13; Stream&lt;String&gt; streamMapped = stream.map((value) -&gt; value.toUpperCase());&#13; </pre>&#13; &#13; &#13; &#13; &#13; <h3>平面地图()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>flatMap()</code>方法将单个元素映射成多个元素。&#13;这个想法是你将每个元素从一个包含多个内部元素的复杂结构中“扁平化”，变成一个只包含这些内部元素的“扁平”流。&#13;</p>&#13; &#13; <p>例如，假设您有一个包含嵌套对象(子对象)的对象。然后，您可以将该对象映射到一个“平面”流中，该流由它自己加上它的嵌套对象组成——或者只有嵌套对象。您还可以将一系列<code>List</code>元素映射到元素本身。或者将一串字符串&#13;映射到这些字符串中的一串单词——或者映射到这些字符串中的单个<code>Character</code>实例。&#13;</p>&#13; &#13; <p>下面是一个将一个<code>List</code>字符串平面映射到每个字符串中的单词的例子。这个例子应该&#13;给你一个关于如何使用<code>flatMap()</code>将一个元素映射到多个元素的想法。&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("One flew over the cuckoo's nest");&#13; stringList.add("To kill a muckingbird");&#13; stringList.add("Gone with the wind");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; stream.flatMap((value) -&gt; {&#13; String[] split = value.split(" ");&#13; return (Stream&lt;String&gt;) Arrays.asList(split).stream();&#13; })&#13; .forEach((value) -&gt; System.out.println(value))&#13; ;&#13; </pre>&#13; &#13; <p>这个 Java <code>Stream</code> <code>flatMap()</code>示例首先创建一个包含书籍标题的<code>List</code>，它有 3 个字符串&#13;。然后为<code>List</code>获得一个<code>Stream</code>，并调用<code>flatMap()</code> &#13;。&#13;</p>&#13; &#13; <p>在<code>Stream</code>上调用的<code>flatMap()</code>操作必须返回另一个代表平面映射元素的<code>Stream</code> &#13;。在上面的例子中，每个原始字符串被拆分成单词，将&#13;转换成<code>List</code>，流从<code>List</code>获得并返回。&#13;</p>&#13; &#13; <p>注意，这个例子以调用<code>forEach()</code>结束，这是一个终端操作。这个调用&#13;仅仅是为了触发内部迭代，从而触发平面图操作。如果在<code>Stream</code>链上没有调用&#13;终端操作，就不会发生任何事情。实际上不会发生平面映射。&#13;</p>&#13; &#13; &#13; &#13; &#13; <h3>独特()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>distinct()</code>方法是一个非终结操作，它返回一个新的&#13; <code>Stream</code>，其中只包含来自原始流的不同元素。任何重复的&#13;都将被删除。下面是一个 Java <code>Stream</code> <code>distinct()</code>方法的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("one");&#13; stringList.add("two");&#13; stringList.add("three");&#13; stringList.add("one");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; List&lt;String&gt; distinctStrings = stream&#13; .distinct()&#13; .collect(Collectors.toList());&#13; &#13; System.out.println(distinctStrings);&#13; </pre>&#13; &#13; <p>在这个例子中，元素<code>one</code>在原始流中出现了 2 次。只有该元素的第一次出现&#13;才会被包含在<code>distinct()</code>返回的<code>Stream</code>中。因此，&#13;产生的<code>List</code>(调用<code>collect()</code>)将只包含<code>one</code>、<code>two</code>、T10】和<code>three</code>。该示例打印的输出将是:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; [one, two, three]&#13; </pre>&#13; &#13; &#13; &#13; &#13; &#13; <h3>极限()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>limit()</code>方法可以将流中的元素数量限制为&#13;一个作为参数提供给<code>limit()</code>方法的数字。<code>limit()</code>方法返回一个&#13;新的<code>Stream</code>，它最多包含给定数量的元素。下面是一个&#13; Java <code>Stream</code> <code>limit()</code>的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("one");&#13; stringList.add("two");&#13; stringList.add("three");&#13; stringList.add("one");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; stream&#13; .limit(2)&#13; .forEach( element -&gt; { System.out.println(element); }); &#13; </pre>&#13; &#13; <p>这个例子首先创建一个<code>Stream</code>，然后对它调用<code>limit()</code>，然后&#13;用一个输出流中元素的 lambda 调用<code>forEach()</code>。由于<code>limit(2)</code>调用，只有两个&#13;第一个元素将被打印。&#13;</p>&#13; &#13; &#13; &#13; &#13; <h3>peek()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>peek()</code>方法是一个以&#13; a <code>Consumer</code> ( <code>java.util.function.Consumer</code>)为参数的非终结操作。对于流中的每个元素，&#13; <code>Consumer</code>都将被调用。<code>peek()</code> &#13;方法返回一个新的<code>Stream</code>，它包含原始流中的所有元素。&#13;</p>&#13; &#13; <p>正如该方法所说，<code>peek()</code>方法的目的是查看流中的元素&#13;，而不是转换它们。请记住，<code>peek</code>方法不会&#13;开始流中元素的内部迭代。为此，您需要调用一个终端操作&#13;。下面是一个 Java<code>Stream</code>T3 的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("abc");&#13; stringList.add("def");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; Stream&lt;String&gt; streamPeeked = stream.peek((value) -&gt; {&#13; System.out.println("value");&#13; });&#13; </pre>&#13; &#13; &#13; &#13; &#13; &#13; &#13; <h2>终端操作</h2>&#13; <p>Java <code>Stream</code>接口的终端操作通常返回一个值。一旦在一个<code>Stream</code>上调用了&#13;终端操作，<code>Stream</code>和链接流的任何&#13;的迭代将开始。一旦迭代完成，就返回终端操作&#13;的结果。&#13;</p>&#13; &#13; <p>终端操作通常不会返回新的<code>Stream</code>实例。因此，一旦您在流上调用了终端操作&#13;，来自非终端操作的<code>Stream</code>实例链就结束了。&#13;下面是一个在 Java 上调用终端操作的例子<code>Stream</code> : &#13;</p>&#13; &#13; <pre class="codeBox">&#13; long count = stream&#13; .map((value) -&gt; { return value.toLowerCase(); })&#13; .map((value) -&gt; { return value.toUpperCase(); })&#13; .map((value) -&gt; { return value.substring(0,3); })&#13; .count();&#13; </pre>&#13; &#13; <p>例子最后对<code>count()</code>的调用就是终端操作。由于&#13; <code>count()</code>返回一个<code>long</code>，所以<code>Stream</code>非终结操作链&#13;(<code>map()</code>调用)结束。&#13;</p>&#13; &#13; &#13; &#13; &#13; <h3>任意匹配()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>anyMatch()</code>方法是一个终端操作，它将单个&#13; <code>Predicate</code>作为参数，开始<code>Stream</code>的内部迭代，&#13;将<code>Predicate</code>参数应用于每个元素。如果<code>Predicate</code>为任何元素返回&#13;真，则<code>anyMatch()</code>方法返回<code>true</code>。&#13;如果没有元素与<code>Predicate</code>匹配，<code>anyMatch()</code>将返回<code>false</code>。&#13;下面是一个 Java <code>Stream</code> <code>anyMatch()</code>的例子:&#13;</p>&#13; &#13; &#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("One flew over the cuckoo's nest");&#13; stringList.add("To kill a muckingbird");&#13; stringList.add("Gone with the wind");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; boolean anyMatch = stream.anyMatch((value) -&gt; { return value.startsWith("One"); });&#13; System.out.println(anyMatch);&#13; </pre>&#13; &#13; <p>在上面的例子中，<code>anyMatch()</code>方法调用将返回<code>true</code>，因为&#13;流中的第一个字符串元素以“一”开始。&#13;</p>&#13; &#13; &#13; &#13; &#13; &#13; <h3>allMatch()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>allMatch()</code>方法是一个终端操作，它将单个&#13; <code>Predicate</code>作为参数，启动<code>Stream</code>、&#13;中元素的内部迭代，并将<code>Predicate</code>参数应用于每个元素。如果<code>Predicate</code>为<code>Stream</code>中的所有元素返回&#13; <code>true</code>，则<code>allMatch()</code>将返回<code>true</code>。&#13;如果不是所有元素都与<code>Predicate</code>匹配，<code>allMatch()</code>方法返回<code>false</code>。&#13;下面是一个 Java <code>Stream</code> <code>allMatch()</code>的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("One flew over the cuckoo's nest");&#13; stringList.add("To kill a muckingbird");&#13; stringList.add("Gone with the wind");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; boolean allMatch = stream.allMatch((value) -&gt; { return value.startsWith("One"); });&#13; System.out.println(allMatch);&#13; </pre>&#13; &#13; <p>在上面的例子中，<code>allMatch()</code>方法将返回<code>false</code>，因为<code>Stream</code>中只有一个&#13;字符串以“1”开头。&#13;</p>&#13; &#13; &#13; &#13; &#13; <h3>无匹配()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>noneMatch()</code>方法是一个终端操作，它将迭代&#13;流中的元素并返回<code>true</code>或<code>false</code>，这取决于流中是否没有&#13;元素与作为参数传递给<code>noneMatch()</code>的<code>Predicate</code>相匹配。&#13;如果&#13;和<code>Predicate</code>没有匹配的元素，则<code>noneMatch()</code>方法将返回<code>true</code>，如果匹配了一个或多个元素，则返回<code>false</code>。&#13;下面是一个 Java <code>Stream</code> <code>noneMatch()</code>的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("abc");&#13; stringList.add("def");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; boolean noneMatch = stream.noneMatch((element) -&gt; {&#13; return "xyz".equals(element);&#13; });&#13; &#13; System.out.println("noneMatch = " + noneMatch);&#13; </pre>&#13; &#13; &#13; &#13; &#13; &#13; <h3>收集()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>collect()</code>方法是一个终端操作，它启动元素的内部&#13;迭代，并将流中的元素收集到某种集合或对象中。&#13;下面是一个简单的 Java <code>Stream</code>方法示例:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("One flew over the cuckoo's nest");&#13; stringList.add("To kill a muckingbird");&#13; stringList.add("Gone with the wind");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; List&lt;String&gt; stringsAsUppercaseList = stream&#13; .map(value -&gt; value.toUpperCase())&#13; .collect(Collectors.toList());&#13; &#13; System.out.println(stringsAsUppercaseList);&#13; </pre>&#13; &#13; <p><code>collect()</code>方法将一个<code>Collector</code> ( <code>java.util.stream.Collector</code>)作为&#13;参数。实现一个<code>Collector</code>需要对<code>Collector</code>接口进行一些研究。&#13;幸运的是，Java 类<code>java.util.stream.Collectors</code>包含一组预实现的&#13; <code>Collector</code>实现，您可以使用它们来完成最常见的操作。在上面的例子中，&#13;使用的是由<code>Collectors.toList()</code>返回的<code>Collector</code>实现。&#13;这个<code>Collector</code>简单地收集了一个标准 Java <code>List</code> &#13;流中的所有元素</p>&#13; &#13; &#13; &#13; &#13; <h3>计数()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>count()</code>方法是一个终端操作，它启动<code>Stream</code>中元素的内部迭代&#13;，并对元素进行计数。下面是一个 Java <code>Stream</code> <code>count()</code> &#13;的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("One flew over the cuckoo's nest");&#13; stringList.add("To kill a muckingbird");&#13; stringList.add("Gone with the wind");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; long count = stream.flatMap((value) -&gt; {&#13; String[] split = value.split(" ");&#13; return (Stream&lt;String&gt;) Arrays.asList(split).stream();&#13; })&#13; .count();&#13; &#13; System.out.println("count = " + count);&#13; </pre>&#13; &#13; <p>这个例子首先创建一个字符串的<code>List</code>，然后获取那个<code>List</code>的<code>Stream</code>，&#13;为其添加一个<code>flatMap()</code>操作，然后以对<code>count()</code>的调用结束。&#13; <code>count()</code>方法将开始迭代<code>Stream</code>中的元素，这将导致&#13;中的字符串元素在<code>flatMap()</code>操作中被拆分成单词，然后被计数。&#13;打印出来的最终结果是 14。&#13;</p>&#13; &#13; &#13; &#13; &#13; &#13; <h3>findAny()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>findAny()</code>方法可以从流中找到单个元素。找到的&#13;元素可以来自<code>Stream</code>的任何地方。不能保证元素是从&#13;流中的什么地方获取的。下面是一个 Java <code>Stream</code> <code>findAny()</code>的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("one");&#13; stringList.add("two");&#13; stringList.add("three");&#13; stringList.add("one");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; Optional&lt;String&gt; anyElement = stream.findAny();&#13; &#13; System.out.println(anyElement.get());&#13; </pre>&#13; &#13; <p>注意<code>findAny()</code>方法是如何返回一个<code>Optional</code>的。<code>Stream</code>可能为空——因此没有元素可以返回。你可以通过<code>Optional</code> &#13; <code>isPresent()</code>方法检查一个元素是否被找到。&#13;</p>&#13; &#13; &#13; &#13; &#13; &#13; <h3>findFirst()</h3>&#13; <p>Java <code>Stream</code> <code>findFirst()</code>方法查找<code>Stream</code>&#13;中的第一个元素，如果<code>Stream</code>中存在任何元素的话。<code>findFirst()</code>方法返回一个&#13; <code>Optional</code>，从中可以获取元素(如果存在的话)。下面是一个&#13; Java <code>Stream</code> <code>findFirst()</code>的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("one");&#13; stringList.add("two");&#13; stringList.add("three");&#13; stringList.add("one");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; Optional&lt;String&gt; result = stream.findFirst();&#13; &#13; System.out.println(result.get());&#13; </pre>&#13; &#13; <p>您可以通过其<code>isPresent()</code> &#13;方法检查返回的<code>Optional</code>是否包含元素。&#13;</p>&#13; &#13; &#13; &#13; &#13; &#13; <h3>forEach()</h3>&#13; <p>Java <code>Stream</code> <code>forEach()</code>方法是一个终端操作，它启动<code>Stream</code>中元素的&#13;内部迭代，并将<code>Consumer</code> &#13; ( <code>java.util.function.Consumer</code>)应用于<code>Stream</code>中的每个元素。&#13; <code>forEach()</code>方法返回<code>void</code>。下面是一个&#13;Java<code>Stream</code>T9】的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("one");&#13; stringList.add("two");&#13; stringList.add("three");&#13; stringList.add("one");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; stream.forEach( element -&gt; { System.out.println(element); });&#13; </pre>&#13; &#13; &#13; &#13; &#13; &#13; <h3>最小值()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>min()</code>方法是一个终端操作，它返回<code>Stream</code>中最小的&#13;元素。哪个元素最小是由传递给<code>min()</code>方法的<code>Comparator</code> &#13;实现决定的。我已经在关于对 Java 集合排序的教程中解释了接口如何工作。&#13;下面是一个 Java <code>Stream</code> <code>min()</code>的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("abc");&#13; stringList.add("def");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; Optional&lt;String&gt; min = stream.min((val1, val2) -&gt; {&#13; return val1.compareTo(val2);&#13; });&#13; &#13; String minString = min.get();&#13; &#13; System.out.println(minString);&#13; </pre>&#13; &#13; <p>注意<code>min()</code>方法如何返回一个<code>Optional</code>，它可能包含也可能不包含&#13;结果。如果<code>Stream</code>为空，<code>Optional</code> <code>get()</code>方法将&#13;抛出一个<code>NoSuchElementException</code>。&#13;</p>&#13; &#13; &#13; &#13; &#13; &#13; <h3>最大()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>max()</code>方法是一个终端操作，它返回<code>Stream</code>中最大的&#13;元素。哪个元素最大是由传递给<code>max()</code>方法的<code>Comparator</code> &#13;实现决定的。我已经在关于对 Java 集合排序的教程中解释了接口如何工作。&#13;下面是一个 Java <code>Stream</code> <code>max()</code>的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("abc");&#13; stringList.add("def");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; Optional&lt;String&gt; max = stream.max((val1, val2) -&gt; {&#13; return val1.compareTo(val2);&#13; });&#13; &#13; String maxString = max.get();&#13; &#13; System.out.println(maxString);&#13; </pre>&#13; &#13; <p>注意<code>max()</code>方法如何返回一个<code>Optional</code>，它可能包含也可能不包含&#13;结果。如果<code>Stream</code>为空，<code>Optional</code> <code>get()</code>方法将&#13;抛出一个<code>NoSuchElementException</code>。&#13;</p>&#13; &#13; &#13; &#13; &#13; &#13; <h3>减少()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>reduce()</code>方法是一个终端操作，可以将流中的所有元素简化为一个单独的&#13;元素。下面是一个 Java<code>Stream</code>T3 的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("One flew over the cuckoo's nest");&#13; stringList.add("To kill a muckingbird");&#13; stringList.add("Gone with the wind");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; Optional&lt;String&gt; reduced = stream.reduce((value, combinedValue) -&gt; {&#13; return combinedValue + " + " + value;&#13; });&#13; &#13; System.out.println(reduced.get());&#13; </pre>&#13; &#13; <p>注意由<code>reduce()</code>方法返回的<code>Optional</code>。这个<code>Optional</code> &#13;包含传递给<code>reduce()</code>方法的 lambda 表达式返回的值(如果有的话)。&#13;您通过调用<code>Optional</code> <code>get()</code>方法来获取该值。&#13;</p>&#13; &#13; &#13; &#13; &#13; &#13; <h3>托阵列()</h3>&#13; &#13; <p>Java <code>Stream</code> <code>toArray()</code>方法是一个终端操作，它启动流中元素的内部迭代&#13;，并返回包含所有元素的数组<code>Object</code>。下面是&#13;一个 Java <code>Stream</code> <code>toArray()</code>的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("One flew over the cuckoo's nest");&#13; stringList.add("To kill a muckingbird");&#13; stringList.add("Gone with the wind");&#13; &#13; Stream&lt;String&gt; stream = stringList.stream();&#13; &#13; Object[] objects = stream.toArray();&#13; </pre>&#13; &#13; &#13; &#13; &#13; <h2>串联流</h2>&#13; &#13; <p>Java <code>Stream</code>接口包含一个名为<code>concat()</code>的静态方法，它可以将&#13;两个流连接成一个流。结果是一个新的<code>Stream</code>，它包含第一个&#13;流中的所有元素，后面是第二个流中的所有元素。&#13;下面是一个使用 Java <code>Stream</code> <code>concat()</code>方法的例子:&#13;</p>&#13; &#13; &#13; <pre class="codeBox">&#13; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();&#13; &#13; stringList.add("One flew over the cuckoo's nest");&#13; stringList.add("To kill a muckingbird");&#13; stringList.add("Gone with the wind");&#13; &#13; Stream&lt;String&gt; stream1 = stringList.stream();&#13; &#13; List&lt;String&gt; stringList2 = new ArrayList&lt;&gt;();&#13; stringList2.add("Lord of the Rings");&#13; stringList2.add("Planet of the Rats");&#13; stringList2.add("Phantom Menace");&#13; &#13; Stream&lt;String&gt; stream2 = stringList2.stream();&#13; &#13; Stream&lt;String&gt; concatStream = Stream.concat(stream1, stream2);&#13; &#13; List&lt;String&gt; stringsAsUppercaseList = concatStream&#13; .collect(Collectors.toList());&#13; &#13; System.out.println(stringsAsUppercaseList);&#13; </pre>&#13; &#13; &#13; &#13; &#13; <h2>从数组创建流</h2>&#13; &#13; <p>Java <code>Stream</code>接口包含一个名为<code>of()</code>的静态方法，可以使用&#13;从一个或多个对象创建一个<code>Stream</code>。下面是一个使用&#13; Java <code>Stream</code> <code>of()</code>方法的例子:&#13;</p>&#13; &#13; <pre class="codeBox">&#13; Stream&lt;String&gt; streamOf = Stream.of("one", "two", "three");&#13; </pre>&#13; &#13; &#13; &#13; &#13; &#13; <h2>Java 流 API 评论</h2>&#13; &#13; <p>在使用过其他数据流 API(如 Apache Kafka Streams API)之后，我对 Java Stream API 有一些评论，我将与您分享。它们不是很重要的评论点，但是当你冒险进入流处理时，它们是有用的。</p>&#13; &#13; &#13; &#13; &#13; <h3>批处理，非流式</h3>&#13; &#13; <p>尽管名为 Java Stream API，但它并不是真正的流处理 API。Java Stream API 的终端操作返回遍历流中所有元素的最终结果，并向元素提供非终端和终端操作。处理完流中的最后一个元素后，将返回终端操作的结果。</p>&#13; &#13; <p>在处理完一个流的最后一个元素后返回一个<em>最终结果</em>只有在你&#13;知道流中最后一个元素是什么的情况下才有可能。知道一个给定元素是否是一个&#13;流中的最后一个元素的唯一方法是，如果你正在处理一个<em>批处理</em>，它有一个<em>最后一个元素</em>。相反，真正的流&#13;没有最后的元素。你永远不知道一个给定的元素是否是最后一个。因此，&#13;不可能在流上执行终端操作。您所能做的最好的事情是在给定元素的处理之后收集临时结果&#13;，但是这将是<em>采样</em>，而不是<em>最终结果</em>。&#13;</p>&#13; &#13; &#13; &#13; &#13; &#13; <h3>链，不是图</h3>&#13; &#13; <p>Java 流 API 被设计成一个<code>Stream</code>实例只能被操作一次。换句话说，&#13;你只能给一个<code>Stream</code>增加一个非终结操作，从而产生一个新的<code>Stream</code> &#13;对象。您可以向生成的<code>Stream</code>对象添加另一个非终结操作，但不能先向&#13;添加。非终结<code>Stream</code>实例的结果结构形成了一个链。&#13;</p>&#13; &#13; <p>在真正的流处理 API 中，根流和事件监听器通常可以形成一个图，而不仅仅是一个链。多个侦听器可以侦听根流，并且每个侦听器可以用自己的方式处理流中的元素，并且可以转发转换后的元素作为结果。因此，每个监听器(非终端操作)通常可以充当流本身，其他监听器可以监听其结果。Apache Kafka Streams 就是这样设计的。每个侦听器(中间流)也可以有多个侦听器。由此产生的结构形成了监听器与监听器之间的图，等等。</p>&#13; &#13; <p>使用流处理图而不是链，在图中没有单一的最终操作。我所说的最后一道工序是指保证是加工链中的最后一道工序。相反，可以有多个最终操作。图中的每一片“叶子”都是最后一道工序。</p>&#13; &#13; <p>当您的流处理结构可以是具有多个最终操作的图时，流 API 不能像 Java 流 API 那样容易地支持终端操作。为了方便地支持终端操作，必须有一个返回最终结果的最终操作。基于图的流处理 API 可以替代地支持“采样”操作，其中流处理图中的每个节点被要求它可能在内部保存的任何值(例如，总和)，如果有的话(纯转换监听器节点将不具有任何内部状态)。</p>&#13; &#13; &#13; &#13; &#13; &#13; <h3>内部迭代，而不是外部迭代</h3>&#13; &#13; <p>Java 流 API 被特意设计成在一个<code>Stream</code>中有元素的内部迭代。&#13;当在<code>Stream</code>上调用终端操作时，迭代开始。事实上，为了让&#13;终端操作能够返回结果，终端操作必须启动<code>Stream</code>中&#13;元素的迭代。&#13;</p>&#13; &#13; <p>一些基于图形的流处理 API 也被设计成对 API 的用户隐藏元素的迭代(例如 Apache Kafka Streams 和 RxJava)。然而，就我个人而言，我更喜欢这样一种设计，其中每个流节点(根流和侦听器)都可以通过方法调用将元素传递给它们，并让元素通过完整的图进行处理。这样的设计将使测试图中的每个侦听器变得更加容易，因为您可以配置图，然后通过它推送元素，最后检查结果(图的采样状态)。这种设计还将使流处理图能够通过图中的多个节点将元素推入其中，而不仅仅是通过根流。</p> </body> </html></iframe>