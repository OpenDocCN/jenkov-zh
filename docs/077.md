# Java 尝试使用资源

> 原文：<https://jenkov.com/tutorials/java-exception-handling/try-with-resources.html>

Java *try with resources* 构造，又名*Java try-with resources*，是一种异常处理机制，可以在您使用完资源时自动关闭资源，如 Java InputStream 或 JDBC 连接。为此，您必须打开并使用 Java *try-with-resources* 块中的资源。当执行离开 *try-with-resources* 块时，在 *try-with-resources* 块中打开的任何资源都将自动关闭，无论是否从 *try-with-resources* 块内部或在试图关闭资源时抛出任何异常。

这个 *Java try-with-resources 教程*解释了 *Java try-with-resources* 构造如何工作，如何正确地使用它，以及如何处理从 *try-with-resources* 块内部以及在关闭资源期间抛出的异常。

## 资源试用视频

我创建了这个 Java 资源尝试教程的视频版本，如果你喜欢的话:

<iframe width="560" height="315" src="https://www.youtube.com/embed/GBtQW3XF3Lg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""><h2>用资源尝试</h2> <p>为了了解 Java <em> try-with-resources </em>构造是如何工作的，让我们看一个 Java <em> try-with-resources </em>的例子:</p> <pre class="codeBox"> private static void printFile() throws IOException { try(FileInputStream input = new FileInputStream("file.txt")) { int data = input.read(); while(data != -1){ System.out.print((char) data); data = input.read(); } } } </pre> <p>这个<em> try-with-resources </em>示例展示了如何在<em> try-with-resources </em>块中打开一个<a href="/java-io/fileinputstream.html"> Java FileInputStream </a>，从<code>FileInputStream</code>中读取一些数据，并在执行离开<em> try-with-resources </em>块(未明确显示)时自动关闭<code>FileInputStream</code>。</p> <p>注意上面的<em> try-with-resources </em>示例中方法内的第一行:</p> <pre class="codeBox"> try(FileInputStream input = new FileInputStream("file.txt")) { </pre> <p>这是<em>尝试资源</em>构造。<code>FileInputStream</code>变量在<code>try</code>关键字后的括号内声明。此外，一个<code>FileInputStream</code>被实例化并赋给变量。</p> <p>当<code>try</code>块完成时，<code>FileInputStream</code>将自动关闭。这是可能的，因为<code>FileInputStream</code>实现了 Java 接口<code>java.lang.AutoCloseable</code>。实现该接口的所有类都可以在 try-with-resources 构造中使用。</p> <h2>使用资源进行尝试 Java 9 增强</h2> <p>在 Java 9 之前，必须在 try-with-resources 构造的<em> try </em>块的括号内创建自动关闭的资源。从 Java 9 开始，这就不再需要了。如果引用资源的变量实际上是 final，那么只需在 try 块括号内输入对该变量的引用。下面是 Java 9 <em> try-with-resources </em>增强的一个例子:</p> <pre class="codeBox"> private static void printFile() throws IOException { FileInputStream input = new FileInputStream("file.txt"); try(input) { int data = input.read(); while(data != -1){ System.out.print((char) data); data = input.read(); } } } </pre> <p>注意<code>input</code>变量现在是如何声明的，并且在<em> try </em>块之外分配了一个<code>FileInputStream</code>。还要注意，<code>input</code>变量是如何在<em> try </em>块的括号内引用的。这样，一旦退出<em> try </em>块，Java 仍然会正确关闭它。</p> <h2>使用多种资源</h2> <p>您可以在 Java <em> try-with-resources </em>块中使用多个资源，并让它们自动关闭。下面是一个在<em> try-with-resources </em>块中使用多个资源的例子:</p> <pre class="codeBox"> private static void printFile() throws IOException { try( FileInputStream input = new FileInputStream("file.txt"); BufferedInputStream bufferedInput = new BufferedInputStream(input) ) { int data = bufferedInput.read(); while(data != -1){ System.out.print((char) data); data = bufferedInput.read(); } } } </pre> <p>这个例子在<em> try </em>关键字后的括号内创建了两个资源。一个<code>FileInputStream</code>和一个<code>BufferedInputStream</code>。当执行离开<em> try </em>块时，这两个资源都会自动关闭。</p> <h3>地产禁用令</h3> <p>Java try-with-resources 构造中声明的资源将以与括号中创建/列出它们的顺序相反的顺序关闭。在上一节的例子中，首先关闭 <bufferedinputstream>，然后关闭<code>FileInputStream</code>。</bufferedinputstream></p> <h2>自定义可自动关闭的实现</h2> <p>Java <em> try-with-resources </em>构造不仅仅适用于 Java 的内置类。您也可以在自己的类中实现<code>java.lang.AutoCloseable</code>接口，并将它们与<em> try-with-resources </em>构造一起使用。</p> <p><code>AutoClosable</code>接口只有一个名为<code>close()</code>的方法。界面看起来是这样的:</p> <pre class="codeBox"> public interface AutoClosable { public void close() throws Exception; } </pre> <p>任何实现这个接口的类都可以与 Java <em> try-with-resources </em>构造一起使用。下面是一个简单的实现示例:</p> <pre class="codeBox"> public class MyAutoClosable implements AutoCloseable { public void doIt() { System.out.println("MyAutoClosable doing it!"); } @Override public void close() throws Exception { System.out.println("MyAutoClosable closed!"); } } </pre> <p><code>doIt()</code>方法不是<code>AutoClosable</code>接口的一部分。它在那里是因为我们希望能够做一些事情，而不仅仅是关闭对象。</p> <p>下面是一个如何将<code>MyAutoClosable</code>与<em> try-with-resources </em>构造一起使用的示例:</p> <pre class="codeBox"> private static void myAutoClosable() throws Exception { try(MyAutoClosable myAutoClosable = new MyAutoClosable()){ myAutoClosable.doIt(); } } </pre> <p>下面是调用方法<code>myAutoClosable()</code>时打印到<code>System.out</code>的输出:</p> <pre class="codeBox"> MyAutoClosable doing it! MyAutoClosable closed! </pre> <p>如您所见，<em> try-with-resources </em>是一种非常强大的方法，可以确保在<code>try-catch</code>块中使用的资源被正确关闭，无论这些资源是您自己创建的，还是 Java 的内置组件。</p> <h2>用资源尝试异常处理</h2> <p>Java <em> try-with-resources </em>块的异常处理语义与标准 Java <em> try-catch-finally </em>块的异常处理语义略有不同。在大多数情况下，修改后的语义会比原来的<em> try-catch-finally </em>块的语义更好地为您服务，即使您没有准确理解其中的区别。即便如此，在<em> try-with-resources </em>构造中，实际理解异常处理方式是一个好主意。因此，我将在这里解释<em> try-with-resources </em>构造的异常处理语义。</p> <p>如果从 Java <em> try-with-resources </em>块中抛出异常，那么在<em> try </em>块的括号中打开的任何资源仍然会自动关闭。异常的抛出将强制执行离开<em> try </em>块，这将强制自动关闭资源。一旦资源被关闭，从<em> try </em>块内部抛出的异常将会在调用栈中向上传播。</p> <p>当您试图关闭某些资源时，它们也可能会引发异常。当您试图关闭某个资源时，如果该资源抛出异常，在同一个<em> try-with-resources </em>块中打开的任何其他资源仍将被关闭。关闭所有资源后，失败的关闭尝试的异常将在调用堆栈中向上传播。如果多个资源关闭尝试引发了多个异常，那么遇到的第一个异常将是在调用堆栈中向上传播的异常。其余的异常将被抑制。</p> <p>如果从<em> try-with-resources </em>块内部抛出异常，并且当资源关闭时(当<code>close()</code>被调用时)，在<em> try </em>块内部抛出的异常将被向上传播到调用堆栈。尝试关闭资源时引发的异常将被抑制。这与普通<a href="basic-try-catch-finally.html"> try-catch-finally </a>块中发生的情况相反，在普通块中，遇到的最后一个异常是向上传播到调用堆栈的异常。</p> <p>为了更好地理解 Java <em> try-with-resources </em>构造的异常处理语义，让我们看一些例子。对于这些例子，我创建了下面的<code>AutoClosable</code>实现，我可以在使用和试图关闭时强制抛出异常:</p> <pre class="codeBox"> public class AutoClosableResource implements AutoCloseable { private String name = null; private boolean throwExceptionOnClose = false; public AutoClosableResource(String name, boolean throwExceptionOnClose) { this.name = name; this.throwExceptionOnClose = throwExceptionOnClose; } public void doOp(boolean throwException) throws Exception { System.out.println("Resource " + this.name + " doing operation"); if(throwException) { throw new Exception("Error when calling doOp() on resource " + this.name); } } @Override public void close() throws Exception { System.out.println("Resource " + this.name + " close() called"); if(this.throwExceptionOnClose){ throw new Exception("Error when trying to close resource " + this.name); } } } </pre> <p>首先，让我们看一个使用单一资源的基本示例:</p> <pre class="codeBox"> public static void main(String[] args){ try { tryWithResourcesSingleResource(); } catch (Exception e) { e.printStackTrace(); Throwable[] suppressed = e.getSuppressed(); } } public static void tryWithResourcesSingleResource() throws Exception { try(AutoClosableResource resourceOne = new AutoClosableResource("One", false)) { resourceOne.doOp(false); } } </pre> <p>如果<code>AutoClosableResource</code>构造的第二个参数被更改为<code>true</code>，它将在试图关闭时抛出一个异常。在这种情况下，当试图关闭时抛出的异常将沿调用堆栈向上传播到<code>main()</code>方法，在那里<em> try-catch </em>块将捕获它。在这种情况下，从<code>e.getSuppessed()</code>返回的<code>Throwable</code>数组将是一个空数组(大小为 0)。</p> <p>如果<code>resourceOne.doOp()</code>的参数也被更改为<code>true</code>,<code>doOp()</code>方法将抛出一个异常。在这种情况下，就是这个异常被向上传播到调用栈的<code>main()</code>方法。试图关闭资源时抛出的异常可以在由<code>e.getSuppressed()</code>返回的<code>Throwable</code>数组中找到。</p> <p>让我们看一个使用两个<code>AutoClosable</code>资源的例子:</p> <pre class="codeBox"> public static void main(String[] args){ try { tryWithResourcesTwoResources(); } catch (Exception e) { e.printStackTrace(); Throwable[] suppressed = e.getSuppressed(); System.out.println("suppressed = " + suppressed); } } public static void tryWithResourcesTwoResources() throws Exception { try(AutoClosableResource resourceOne = new AutoClosableResource("One", true); AutoClosableResource resourceTwo = new AutoClosableResource("Two", true) ){ resourceOne.doOp(true); resourceTwo.doOp(false); } } </pre> <p>在只有一个资源抛出异常的情况下，无论是在使用期间还是试图关闭时，行为都与只使用一个资源时相同。然而，在上面的例子中，我已经强制两个资源在试图关闭时抛出异常，并且第一个资源在使用时抛出异常(当调用<code>doOp()</code>时)。在这种情况下，从<em> try </em>块内部抛出的异常会向上传播到调用堆栈。试图关闭资源时抛出的两个异常在由<code>e.getSuppressed()</code>返回的<code>Throwable</code>数组中可用。</p> <p>记住，在<em> try </em>块中只能抛出一个异常。一旦抛出异常，<em> try </em>块代码就会退出，并且尝试关闭资源。</p> <h3>捕捉块</h3> <p>您可以将一个<em> catch </em>块添加到一个<em> try-with-resources </em>块中，就像您可以添加到一个标准的<em> try </em>块中一样。如果从<em> try-with-resources </em>块的<em> try </em>块中抛出异常，那么<em> catch </em>块将捕获它，就像它与标准的<em> try </em>构造一起使用时一样。</p> <p>在进入<em> catch </em>块之前，<em> try-with-resources </em>构造将尝试关闭在<em> try </em>块中打开的资源。如果在试图关闭其中一个资源时抛出异常，这些异常将可以从<em> catch </em>块中的异常的<code>getSuppressed()</code>方法中获得。下面是一个 Java <em> try-with-resources </em>块与一个<em> catch </em>块的例子:</p> <pre class="codeBox"> try(AutoClosableResource resourceOne = new AutoClosableResource("One", true)) { resourceOne.doOp(true); } catch(Exception e) { Throwable[] suppressed = e.getSuppressed(); throw e; } </pre> <p>在上面的例子中，<code>AutoClosableResource</code>被配置为在调用<code>doOp()</code>和试图关闭(通过<code>close()</code>)时抛出异常。从<code>doOp()</code>抛出的异常在<em> catch </em>块中被捕获，它的<code>getSuppressed()</code>方法返回一个数组，该数组包含当试图关闭资源时抛出的异常。</p> <p>如果只有在试图关闭资源时才抛出异常，那么<em> catch </em>块也将捕获它。该异常的<code>getSuppressed()</code>方法将返回一个空数组，因为没有隐藏异常。</p> <h3>最终阻止</h3> <p>也可以将<em> finally </em>块添加到 Java <em> try-with-resources </em>块中。它的行为就像一个标准的<em> finally </em>块，这意味着它将在退出<em> try-with-resources </em>块之前的最后一步被执行——在任何<em> catch </em>块被执行之后。</p> <p>如果您从<em> try-with-resources </em>构造的<em> finally </em>块中抛出一个异常，所有之前抛出的异常都将丢失！下面是一个从 Java <em> try-with-resources </em>构造的<em> finally </em>块中抛出异常的例子:</p> <pre class="codeBox"> public static void main(String[] args){ try { tryWithResourcesSingleResource(); } catch (Exception e) { e.printStackTrace(); Throwable[] suppressed = e.getSuppressed(); } } public static void tryWithResourcesSingleResource() throws Exception { try(AutoClosableResource resourceOne = new AutoClosableResource("One", true)) { resourceOne.doOp(false); } catch(Exception e) { Throwable[] suppressed = e.getSuppressed(); throw e; } finally { throw new Exception("Hey, an exception from the finally block"); } } </pre> <p>注意，从<em> catch </em>块中抛出的异常将被忽略，因为新的异常是从<em> finally </em>块中抛出的。如果没有<em>挡</em>挡，也是如此。那么从<em> try </em>块内部抛出的任何异常都会丢失，因为新的异常是从<em> finally </em>块内部抛出的。任何先前的异常都没有被抑制，所以它们在从<em> finally </em>块抛出的异常中不可用。</p> <h3>手动添加隐藏的异常</h3> <p><code>Throwable</code>类有一个名为<code>addSuppressed()</code>的方法，它将一个<code>Throwable</code>对象作为参数。如果你需要的话，使用<code>addSuppressed()</code>方法可以将被抑制的异常添加到另一个异常中。下面的示例展示了如何手动将隐藏的异常添加到 Java 异常中:</p> <pre class="codeBox"> Exception finalException = null; try(AutoClosableResource resourceOne = new AutoClosableResource("One", true)) { resourceOne.doOp(false); } catch(Exception e) { finalException = new Exception("Error..."); finalException.addSuppressed(e); for(Throwable suppressed : e.getSuppressed()){ finalException.addSuppressed(suppressed); } } finally { if(finalException != null){ throw finalException; } } </pre> <p>注意如何在<em> try-with-resources </em>构造之外声明<code>Throwable</code>引用。否则<em>捕捉</em>和<em>最后</em>块不能访问。</p> <p>在大多数情况下，您不需要手动将隐藏的异常添加到异常中，但是现在您至少已经看到了如何做，以防您遇到需要它的情况。</p> <h2>资源管理与尝试-捕捉-最后，老学校的风格</h2> <p>Java 7 中添加了 Java <em> try-with-resources </em>构造。在 Java 7 之前，管理需要显式关闭的资源有些繁琐。您必须手动处理资源的正确关闭。这不是一个容易正确处理的任务。要理解为什么，请看下面的方法，该方法读取一个文件并将其打印到<code>System.out</code>:</p> <pre class="codeBox"> private static void printFile() throws IOException { InputStream input = null; try { input = <b>new FileInputStream("file.txt");</b> int data = <b>input.read();</b> while(data != -1){ System.out.print((char) data); data = <b>input.read();</b> } } finally { if(input != null){ <b>input.close();</b> } } } </pre> <p>粗体标记的代码是代码可以抛出<code>Exception</code>的地方。如你所见，这可能发生在<code>try</code>区块的 3 个地方，以及<code>finally</code>区块的 1 个地方。</p> <p>无论<code>try</code>程序块是否抛出异常，总是执行<code>finally</code>程序块。这意味着无论<code>try</code>区块发生什么情况，<code>InputStream</code>都是关闭的。或者说，试图关闭。如果关闭失败，<code>InputStream</code>的<code>close()</code>方法也可能抛出异常。</p> <p>假设从<code>try</code>块内部抛出了一个异常。然后执行<code>finally</code>块。想象一下，从<code>finally</code>块中也抛出了一个异常。您认为哪个异常会在调用堆栈中向上传播？</p> <p>从<code>finally</code>块抛出的异常将被向上传播到调用堆栈，即使从<code>try</code>块抛出的异常可能与传播更相关。</p> </body> </html></iframe>