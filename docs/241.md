# 编程范例

> 原文：<https://jenkov.com/tutorials/dev-essentials/programming-paradigms.html>

在本文中，我列出了我作为软件开发人员和/或架构师在工作中遇到的最常见的编程范例。作为一名开发人员，您可能不需要成为所有这些方面的专家，但是在某种程度上了解它们是有用的。

## 编程范例列表

以下是我在本文中涉及的编程范例列表:

*   结构化程序设计
*   函数式编程
*   面向对象编程
*   面向数据的编程
*   可组合编程
    *   依赖注入
*   自上而下与自下而上
*   极简主义者对极大主义者
*   适应性编程
*   进化软件开发
*   自我驱动的发展
    *   CV 驱动开发
    *   偏好驱动的发展
    *   因为——我说——所以驱动发展

在接下来的章节中，我将对这些范例中的每一个进行更详细的阐述，但是因为每一个范例都有自己的一本书，所以我不能在这里涵盖这些范例的每一个细节。

## 结构化程序设计

在我看来，结构化编程(SP)是最基本的编程范式。结构化编程是关于如何编写可读的代码，例如使用变量和方法名，如何使用函数，for + while 循环，递归等。结构化编程还教导如何在没有某些语言中的 GOTO 指令的情况下编程。结构化编程有时被称为过程化编程。“过程”是函数的另一种说法。在一些语言中(比如 Pascal ),函数和过程的区别在于函数返回值而过程不返回值。

## 函数式编程

函数式编程(FP)是一种范例，它教导使用函数将应用程序构造为调用其他函数的函数。函数被认为是第一类“对象”——或“数据”，意味着函数可以作为对象/数据传递——并且以后在需要的地方和时间被调用。函数可以在运行时由其他函数组成。函数可以没有副作用。当处理元素的集合或数组时，递归优于迭代。函数式编程的内容远不止这些，但是在这里一一介绍会占用太多的空间。

## 面向对象编程

面向对象编程(OOP)是一种将属于同一类的数据和函数分组的范例。类内部的函数通常被称为方法。类可以扩展(继承)其他类，从而继承它们的部分或全部数据和函数。一些面向对象的语言也有接口，以及其他特性，比如特征、值类等等。

## 面向数据的编程

面向数据编程是一种用于需要高速处理大量数据的应用程序的范例。例如，计算机游戏或实时分析应用程序经常需要快速处理大量数据。处理大量数据的最快方法是在 RAM 或磁盘(最好是 SSD)上顺序访问数据。因此，面向数据的编程将大量数据保存在 RAM 或磁盘上的大块中，因此可以顺序处理。这不同于面向对象的编程，在面向对象的编程中，应用程序的对象可以分散在整个 RAM 中，而在面向对象的编程中，您通常无法控制每个对象在 RAM 中的确切位置。

## 可组合编程

可组合编程是一种强调将软件拆分(分解)成更小的可组合单元的范例。在函数式编程中，这些单元是明确设计为可与其他函数组合的函数。在面向对象编程中，这些单元是被明确设计成可与其他对象组合的对象。此外，组合式 OOP 倾向于打破一些经典的 OOP 原则，比如封装、“has-a / is a”规则，或者“对象应该知道如何 XYZ”规则。

### 依赖注入

顺便说一下，依赖注入是一种非常常用于实现组件动态可组合性的技术。动态可组合性与静态可组合性相反。在静态可组合性中，总的组合是硬连线在代码中的。在动态可组合性中，组合可以在运行时配置(有时是重新配置)——例如，通过向组件中注入不同的依赖关系。

## 自上而下与自下而上的设计

自顶向下和自底向上是两种不同的软件设计方法。自顶向下的设计意味着从整个系统的“顶部”开始，首先将系统分解成更大的部分，然后每个部分再分解成更小的部分。这个过程被递归地执行，直到达到最小的可感知片段。

自底向上设计意味着通过首先识别最小的合理部分开始设计过程，然后递归地向上到较大的部分，直到到达组件结构的顶部。

在实践中，你经常会完成一些自顶向下的设计和一些自底向上的设计，这取决于你正在设计的部分，以及你在软件生命周期的哪个阶段(早期/中期/晚期)。

## 极简主义与极简主义设计

最小化设计和最大化设计是确定应用程序、框架、工具包或组件功能范围的两种不同方法。最小化方法是最小化软件的范围和责任，使软件小而集中——典型地集中在一个单一的责任上。最大化方法是解决尽可能多的问题，意味着拥有尽可能多的特性。

最小化方法经常(但不总是)被用于确定小组件的范围，无论是在一个更大的软件系统中，还是在工具包或框架中。最大列表法更常用于

## 适应性编程

自适应编程是一种范式，在这种范式中，您的设计选择适应于您的具体需求，而不是从诸如严格的 FP 或 OOP 之类的教条中派生出来的。您的需求驱动设计。当一个给定的设计满足你的需求时，这个设计就足够好了。这并不意味着一种设计是满足您需求的唯一设计。多种设计可能会满足您的需求。在它们之间做出决定取决于你——决定哪一个除了满足你的需求之外还能给你带来最大的好处。然而，满足您的需求是自适应编程中最基本的要求。

自适应编程也使软件设计适应项目的环境。小型代码库不需要像大型代码库那样多的结构。一个只会存在很短时间的代码库不需要像一个会存在很多年或几十年的代码库那样多的结构。拥有单个开发人员(您)的代码库不需要像拥有成百上千开发人员的代码库那样多的结构。随着项目环境的改变，设计也应该改变，以适应当前的环境。这就是我在[进化软件开发](https://jenkov.com/tutorials/evolutionary-software-development/index.html)中提到的“设计调整”。

## 进化软件开发

进化软件开发是一种范式，在这种范式中，软件一次开发一个版本，从最小可行产品开始。从 MVP 中一次一个版本地添加小的特性集， 只要它对项目有意义就尽快。随着软件的发展，设计应该与当前的设计需求 保持一致——正如上面的“自适应编程”中所提到的。我已经在 [进化软件开发](https://jenkov.com/tutorials/evolutionary-software-development/index.html)中更详细地描述了进化软件开发。

在进化软件开发中，我们试图不为明天设计——而只是为今天设计。显然，如果你提前知道你的需求将很快改变，并且你确切地知道如何改变，并且你知道以后改变设计将是大量的工作，提前设计几个交付可能不是一个坏主意。但是我们不会为“我们*可能*得到的未来需求”做推测性的设计。我们只为今天设计，我们确信不久的将来 会到来。

## 自我驱动的发展

自我驱动的开发是一种范例，在这种范例中，软件项目的设计选择是为了满足开发人员的自我，而不是满足项目的需求。在自我驱动的发展中有几个子类，如 CV 驱动的发展和偏好驱动的发展。

自我驱动的开发很少导致伟大的软件设计——但有时会——如果选择的设计实际上与项目很匹配的话(有时确实会这样)。

### CV 驱动开发

在 CV 驱动的开发中，开发人员选择他们认为在他们的 CV 上看起来不错的工具和设计。事件驱动架构和卡夫卡热吗？酷——我们将在这里使用事件驱动架构和卡夫卡。

### 偏好驱动的发展

偏好驱动开发是一种范式，其中工具和设计是根据开发人员的个人偏好来选择的。我喜欢函数式编程的开发人员可能只使用函数式编程技术。对性能非常感兴趣的开发人员可能会坚持要求系统的所有部分都进行高度的性能优化，即使对于给定的项目来说这不是必需的。

### 因为——我说——所以驱动发展

一些开发人员有如此大的自我意识，以至于他们绝对必须在几乎所有代码的设计上留下自己的指纹。他们会支持自己的想法、设计和过程——不是因为它们对项目有很大意义——而是因为他们需要在某种程度上感觉比团队中的其他人“优越”。好吧，这可能有点夸张——但你明白了。这就是我所说的*，因为——我说——如此驱动的发展*——因为一旦你开始钻研 他们的推理——这一切似乎都止于“因为我这么说”——而不是止于合理的首要原则。

不用说，因为--我说--所以驱动的开发通常对软件项目没有好处，而且它通常也会在团队中产生负面的气氛。