# Java 数据类型

> 原文:[https://jenkov.com/tutorials/java/data-types.html](https://jenkov.com/tutorials/java/data-types.html)

正如关于 [Java 变量](variables.html)的正文中所解释的，Java 中的每个变量都有一个数据类型。数据类型分为两组:

*   原始数据类型
*   对象引用

变量在内存中占据一定的空间。变量占用多少内存取决于它的数据类型。

原始数据类型的变量直接在分配给该变量的内存中包含变量值。例如，数字或字符。

对象引用类型的变量不同于基元类型的变量。对象类型的变量也被称为*引用*。变量本身不包含对象，但包含一个对对象的*引用*。引用指向内存中存储整个对象的其他地方。通过存储在变量中的引用，您可以访问被引用对象的字段和方法。可能有许多不同的变量引用同一个对象。这对于原始数据类型是不可能的。

## 原始数据类型

Java 语言包含以下基本数据类型:

| **<nobr>数据类型</nobr>** | **描述** |
| 布尔型 | 二进制值`true`或`false` |
| 字节 | 8 位有符号值，值从-128 到 127 |
| 短的 | 16 位有符号值，取值范围为-32.768 到 32.767 |
| 茶 | 16 位 Unicode 字符 |
| （同 Internationalorganizations）国际组织 | 32 位有符号值，值从-2.147.483.648 到 2.147.483.647 |
| 长的 | 64 位有符号值，值从-9.223.372.036.854.775.808 到 9.223.372.036.854.775.808 |
| 漂浮物 | 32 位浮点值 |
| 两倍 | 64 位浮点值 |

这些是原始数据类型意味着它们既不是对象，也不是对对象的引用(类和对象将在本 Java 教程的后面解释)。

下面是一个如何声明基本类型变量的示例:

```
int myInt;

```

## 对象类型

基本类型也有完整对象的版本。这意味着你可以通过一个对象引用来引用它们，你可以对同一个值有多个引用，你可以像对 Java 中的任何其他对象一样对它们调用方法。下面的核心对象数据类型列表包含基本类型的对象版本。该列表还包含 Java 中的一些其他核心对象类型。

| **<nobr>数据类型</nobr>** | **描述** |
| 布尔代数学体系的 | 二进制值`true`或`false` |
| 字节 | 8 位有符号值，值从-128 到 127 |
| 短的 | 16 位有符号值，取值范围为-32.768 到 32.767 |
| 字符 | 16 位 Unicode 字符 |
| 整数 | 32 位有符号值，值从-2.147.483.648 到 2.147.483.647 |
| 长的 | 64 位有符号值，值从-9.223.372.036.854.775.808 到 9.223.372.036.854.775.808 |
| 浮动 | 32 位浮点值 |
| 两倍 | 64 位浮点值 |
| 线 | 文本数据的 n 字节 Unicode 字符串。不变的 |

注意对象类型是如何在名称的开头用大写字母拼写的，其中原始版本(非对象)是用小写字母拼写的。还有缩写的区别，像`int`对`Integer`、`char`对`Character`。

当然，在 Java API 中还可以使用许多其他组件，但是上面提到的数据类型是核心的 Java 类型。字符串类型在它自己的文本中有更详细的解释: [Java Strings](strings.html) 。

您还可以通过创建自定义类来创建自己的更复杂的数据类型。我将在后面的文章中回到如何做。

下面是如何声明一个核心对象类型的变量(引用):

```
Integer myInteger;

```

当您声明一个对象引用变量时，该引用不指向任何对象。您需要首先创建(实例化)一个对象。这是如何做到的:

```
Integer myInteger;

myInteger = new Integer(45);

```

这个例子使`myInteger`变量引用一个内部包含值 45 的`Integer`对象。正是代码的`new Integer(45)`部分创建了`Integer`对象。

您也可以在声明变量时创建对象，如下所示:

```
Integer myInteger = new Integer(45);

```

## 原始数据类型的对象版本是不可变的

原始数据类型的对象版本是不可变的，这意味着存储在其中的值一旦设置就不能更改。例如，一旦对象被创建，存储在`Integer`对象中的值就不能改变。

但是引用该对象的变量可以指向另一个对象。这里有一个例子:

```
Integer myInteger = new Integer(45);

myInteger = new Integer(33);

```

如您所见，示例中的变量指向另一个`Integer`对象。

## 自动装箱

在 Java 5 之前，你必须在基本类型的对象版本上调用方法，将它们的值作为基本类型输出。例如:

```
Integer myInteger = new Integer(45);

int myInt = myInteger.intValue();

```

在 Java 5 中，你有一个叫做“自动装箱”的概念。这意味着，如果需要的话，Java 可以自动“装箱”对象版本中的原始变量，或者如果需要的话，可以“拆箱”原始数据类型的对象版本。例如，前面的例子可以写成这样:

```
Integer myInteger = new Integer(45);

int myInt = myInteger;

```

在这种情况下，Java 会自动从`myInteger`对象中提取`int`值，并将该值赋给`myInt`。

类似地，在 Java 出现之前，创建原始数据类型变量的对象版本是一项手动操作:

```
int myInt = 45;

Integer myInteger = new Integer(myInt);

```

通过自动装箱，Java 可以帮你做到这一点。现在你可以写:

```
int myInt = 45;

Integer myInteger = myInt;

```

然后，Java 会自动将原始数据类型“装箱”到相应类型的对象版本中。

Java 的自动装箱特性使您能够在通常需要原始数据类型的对象版本的地方使用原始数据类型，反之亦然。不过，有一个陷阱需要记住。object 类型的变量(对对象的引用)可以指向`null`，这意味着它不指向任何东西——没有对象。如果你试图将`null`转换成原始值，你将得到一个`NullPointerException`(一个导致程序失败的错误)。这段代码显示了这样一个例子:

```
Integer myInteger = null;

int myInt = myInteger;

```

这段代码可以正常编译，但是在执行时会产生一个`NullPointerException`，因为变量`myInteger`指向了`null`。因此不可能转换(取消装箱)它所指向的对象的值，因为它不指向任何对象。