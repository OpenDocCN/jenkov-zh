# 事件驱动架构

> 原文:[https://jen kov . com/tutorials/software-architecture/event-driven-architecture . html](https://jenkov.com/tutorials/software-architecture/event-driven-architecture.html)

事件驱动架构是一种架构风格，其中系统中的组件发出事件并对事件做出反应。当某个事件发生时，组件 A 不直接调用组件 B，而是发出一个事件。组件 A 不知道哪些组件监听它的事件。

事件驱动架构既可以在单个流程内部使用，也可以在流程之间使用。例如，GUI 框架通常会大量使用事件。此外，我在关于[并发模型](/java-concurrency/concurrency-models.html)的教程中解释的装配线并发模型(又名反应式、非阻塞并发模型)也使用事件驱动的架构。

在本教程中，我将重点介绍进程间事件驱动架构的外观。因此，当我在本教程的剩余部分写*事件驱动架构*时，这就是我所指的，即使它不是这个术语的唯一含义。

## 流程之间的事件驱动架构

事件驱动架构是一种架构风格，其中传入的系统请求被收集到一个或多个中央事件队列中。从事件队列中，事件被转发到要处理事件的后端服务。

事件驱动架构有时也被称为*消息驱动架构*或*流处理架构*。这些事件可以被看作是一串消息——因此有了另外两个名字。流处理架构也被称为*λ架构*。无论如何，我将继续使用名称为*的事件驱动*架构。

## 事件队列

在事件驱动的架构中，你有一个或多个中央事件队列，所有的事件在被处理之前都被插入其中。下面是带有事件队列的事件驱动架构的简单图示:

![Basic event-driven architecture with event queue.](../Images/943791675c1069dbedb8d413ca6a1d72.png)

事件在插入队列时是有序的，因此您知道系统以什么顺序响应事件。

## 事件日志

写入事件队列的消息可以写入事件日志(通常在磁盘上)。如果系统崩溃，系统可以简单地通过重放事件日志来重建其状态。下面是一个事件驱动的体系结构的图示，该体系结构使用事件日志来保存事件:

![Event-driven architecture with event queue and event log.](../Images/8443ee2a1c9002d76a30590679543641.png)

您还可以备份事件日志，从而备份系统的状态。在将新版本实际部署到生产环境之前，您可以使用该备份来运行新版本的性能测试。或者，您可以重放事件日志的备份，以重现已报告的某些错误。

## 事件收集器

请求通常通过网络到达，例如作为 HTTP 请求或通过其他协议。事件是通过事件收集器从许多来源接收的。下图是添加了事件收集器的事件驱动架构:

![Event-driven architecture with collectors shown.](../Images/8d5d17cfd4bd086e4d10901104675154.png)

## 回复队列

有时你可能需要回复一个请求(事件)。因此，一些事件驱动的架构也有回复队列。下面是一个事件驱动架构的示意图，该架构同时使用了事件队列(入站队列)和回复队列(出站队列):

![Event-driven architecture with reply queue shown.](../Images/c33396b8db57d1627bec1aab0e102b41.png)

如您所见，回复可能必须路由回正确的事件收集器。例如，如果 HTTP 收集器(本质上是一个 web 服务器)将通过 HTTP 接收到的请求发送到事件队列中，那么为该事件生成的回复可能必须再次通过 HTTP 收集器(服务器)发送回客户端。

通常回复队列是不持久的，这意味着它不会被写入事件日志。只有传入的事件才会保存到事件日志中。

## 读取与写入事件

如果您将所有传入的请求归类为事件，那么它们都将被推入事件队列。如果事件队列是持久的(被持久保存到事件日志中),这意味着所有事件都是持久的。持久化事件通常很慢，因此如果我们能够过滤掉一些不需要持久化的事件，我们就有可能提高事件队列的性能。

将事件队列保存到事件日志中的原因是，我们可以重放事件日志，并重新创建事件导致的系统的确切状态。为了支持这一点，实际上只需要持久化改变系统状态的事件。换句话说，您可以将事件分为读取事件和写入事件。读取事件只读取系统状态，但不改变它。写事件改变系统状态。

通过在读事件和写事件之间划分事件，只有写事件需要被持久化。这将提高事件队列的性能。这种性能提升的确切幅度取决于读取和写入事件之间的比率。

为了将事件分为读取和写入事件，在事件到达事件队列之前，必须在事件收集器中进行区分。否则，事件队列无法知道给定的事件是否应该持久化。

您还可以将事件队列一分为二。一个事件队列用于读取事件，一个事件队列用于写入事件。这样，读事件就不会慢于较慢的写事件，事件队列也不必检查每条消息来确定它是否应该被持久化。读取事件队列不保存事件，而写入事件队列总是保存事件。

这是一个事件驱动体系结构的图示，其中事件队列分为读取和写入事件队列:

![Event-driven architecture with read and write queues shown.](../Images/67b0b97cfd064b00947b68fad2bafb2f.png)

是的，用箭头看起来有点混乱，但实际上创建 3 个队列并在它们之间分发消息并没有那么混乱。

## 事件日志重播挑战

在系统崩溃或系统重启等情况下，重放事件日志以重新创建系统状态的能力经常被强调为事件驱动架构的一大优势。在日志可以独立于时间和周围系统重放的情况下，这是一个很大的优势。

但是，完全独立于时间重播事件日志并不总是可能的。在接下来的几节中，我将介绍事件日志重放面临的一些挑战。

### 处理动态值

如前所述，写事件是在处理时可能会改变系统状态的事件。有时，这种状态变化取决于在处理事件时解析的动态值。动态值的例子可以是事件处理的日期和时间(例如，订单日期)或特定日期和时间的货币汇率。

这样的动态值对事件日志重放来说是一个挑战。如果您在不同的日期重播事件日志，处理事件的服务可能会解析不同的动态值，如另一个日期和时间，或另一个汇率。因此，在不同的日期重播事件日志不会导致重新创建与最初处理事件时完全相同的系统状态。

要解决动态值的问题，您可以让写事件队列能够将所需的动态值标记到事件中。然而，要做到这一点，事件队列需要知道每个消息需要什么样的动态值。这将使事件队列的设计变得复杂。每次需要新的动态值时，事件队列都需要知道如何查找该动态值。

另一种解决方案是，写事件队列仅使用事件的日期和时间来标记写事件。有了事件的原始日期和时间，处理事件的服务可以查找在给定日期和时间的动态值。例如，它可以查找当时有效的汇率。这当然要求服务能够基于日期和时间查找动态值，但情况并非总是如此。

### 与外部系统的协调

事件日志重放的另一个挑战是与外部系统的协调。例如，假设您的事件日志包含一家网店的产品订单。当您第一次处理订单时，您的系统可能会将订单发送到外部支付网关，以从客户的信用卡中收取金额。

如果您稍后重放事件日志，您不希望客户为同一订单再次付费。因此，您不希望在重放期间将订单发送到外部支付网关。

## 事件日志重播解决方案

解决日志重放的问题并不总是容易的。有些系统没有问题，可以原样重放事件日志。其他系统可能需要知道原始事件的日期和时间。而其他系统可能需要知道更多的信息，比如在事件的原始处理过程中从外部系统获得的值。

### 重放模式

在任何情况下，任何侦听来自写事件队列的事件的服务都必须知道传入的事件是原始事件还是重播事件。这样，服务可以确定如何处理动态值的解析以及与外部系统的协调。

### 多步事件队列

应对事件日志重放挑战的另一个解决方案是使用多步事件队列。第一步收集所有写事件。第二步解析动态值。第三步与外部系统协调。如果需要重放日志，只重放第三步。跳过步骤 1 和 2。具体如何实现取决于具体的系统。